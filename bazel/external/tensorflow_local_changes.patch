diff --git a/tensorflow/tf_version.bzl b/tensorflow/tf_version.bzl
index e92c2d2ce2a..bc2ea14e48b 100644
--- a/tensorflow/tf_version.bzl
+++ b/tensorflow/tf_version.bzl
@@ -1,14 +1,8 @@
 """Provides project and wheel version data for TensorFlow."""
 
-load(
-    "//tensorflow:tf_version.default.bzl",
-    "SEMANTIC_VERSION_SUFFIX",
-    "VERSION_SUFFIX",
-)
-
 # These constants are used by the targets //third_party/tensorflow/core/public:release_version,
 # //third_party/tensorflow:tensorflow_bzl and //third_party/tensorflow/tools/pip_package:setup_py.
 TF_VERSION = "2.20.0"
 MAJOR_VERSION, MINOR_VERSION, PATCH_VERSION = TF_VERSION.split(".")
-TF_WHEEL_VERSION_SUFFIX = VERSION_SUFFIX
-TF_SEMANTIC_VERSION_SUFFIX = SEMANTIC_VERSION_SUFFIX
+TF_WHEEL_VERSION_SUFFIX = ""
+TF_SEMANTIC_VERSION_SUFFIX = ""
diff --git a/tensorflow/workspace1.bzl b/tensorflow/workspace1.bzl
index 399ff8f7579..b6755a6e68b 100644
--- a/tensorflow/workspace1.bzl
+++ b/tensorflow/workspace1.bzl
@@ -16,7 +16,7 @@ def workspace(with_rules_cc = True):
       with_rules_cc: Unused, to be removed soon.
     """
     llvm_setup(name = "llvm-project")
-    native.register_toolchains("@local_config_python//:py_toolchain")
+    # native.register_toolchains("@local_config_python//:py_toolchain")
     rules_pkg_dependencies()
 
     closure_repositories()
diff --git a/tensorflow/workspace2.bzl b/tensorflow/workspace2.bzl
index 9e49ab40b25..e91df06041d 100644
--- a/tensorflow/workspace2.bzl
+++ b/tensorflow/workspace2.bzl
@@ -20,6 +20,7 @@ load("@local_xla//third_party/FP16:workspace.bzl", FP16 = "repo")
 load("@local_xla//third_party/gemmlowp:workspace.bzl", gemmlowp = "repo")
 load("@local_xla//third_party/git:git_configure.bzl", "git_configure")
 load("@local_xla//third_party/gpus:rocm_configure.bzl", "rocm_configure")
+load("@local_xla//third_party/gpus:cuda_configure.bzl", "cuda_configure")
 load("@local_xla//third_party/gpus:sycl_configure.bzl", "sycl_configure")
 load("@local_xla//third_party/highwayhash:workspace.bzl", highwayhash = "repo")
 load("@local_xla//third_party/hwloc:workspace.bzl", hwloc = "repo")
@@ -105,11 +106,11 @@ def _initialize_third_party():
 
 # Toolchains & platforms required by Tensorflow to build.
 def _tf_toolchains():
-    native.register_execution_platforms("@local_execution_config_platform//:platform")
-    native.register_toolchains("@local_execution_config_python//:py_toolchain")
+    # native.register_execution_platforms("@local_execution_config_platform//:platform")
+    # native.register_toolchains("@local_execution_config_python//:py_toolchain")
 
     # Loads all external repos to configure RBE builds.
-    initialize_rbe_configs()
+    # initialize_rbe_configs()
 
     # Note that we check the minimum bazel version in WORKSPACE.
     clang6_configure(name = "local_config_clang6")
@@ -117,9 +118,10 @@ def _tf_toolchains():
     tensorrt_configure(name = "local_config_tensorrt")
     git_configure(name = "local_config_git")
     syslibs_configure(name = "local_config_syslibs")
-    python_configure(name = "local_config_python")
+    # python_configure(name = "local_config_python")
+    cuda_configure(name = "local_config_cuda")
     rocm_configure(name = "local_config_rocm")
-    sycl_configure(name = "local_config_sycl")
+    # sycl_configure(name = "local_config_sycl")
     remote_execution_configure(name = "local_config_remote_execution")
 
     # For windows bazel build
diff --git a/third_party/xla/third_party/gpus/cuda_configure.bzl b/third_party/xla/third_party/gpus/cuda_configure.bzl
index d110fa81460..80fccbfa234 100644
--- a/third_party/xla/third_party/gpus/cuda_configure.bzl
+++ b/third_party/xla/third_party/gpus/cuda_configure.bzl
@@ -278,7 +278,7 @@ def _cuda_include_path(repository_ctx, cuda_config):
 
 def enable_cuda(repository_ctx):
     """Returns whether to build with CUDA support."""
-    return int(get_host_environ(repository_ctx, "TF_NEED_CUDA", False))
+    return int(False)
 
 def matches_version(environ_version, detected_version):
     """Checks whether the user-specified version matches the detected version.
diff --git a/third_party/xla/third_party/gpus/rocm_configure.bzl b/third_party/xla/third_party/gpus/rocm_configure.bzl
index 80c151cde4d..b044e061473 100644
--- a/third_party/xla/third_party/gpus/rocm_configure.bzl
+++ b/third_party/xla/third_party/gpus/rocm_configure.bzl
@@ -158,12 +158,6 @@ def _rocm_include_path(repository_ctx, rocm_config, bash_bin):
     return inc_dirs
 
 def _enable_rocm(repository_ctx):
-    enable_rocm = get_host_environ(repository_ctx, "TF_NEED_ROCM")
-    if enable_rocm == "1":
-        if get_cpu_value(repository_ctx) != "Linux":
-            auto_configure_warning("ROCm configure is only supported on Linux")
-            return False
-        return True
     return False
 
 def _amdgpu_targets(repository_ctx, rocm_toolkit_path, bash_bin):
diff --git a/third_party/xla/third_party/gpus/sycl_configure.bzl b/third_party/xla/third_party/gpus/sycl_configure.bzl
index ee63624f8e4..d60a10b10d6 100644
--- a/third_party/xla/third_party/gpus/sycl_configure.bzl
+++ b/third_party/xla/third_party/gpus/sycl_configure.bzl
@@ -63,7 +63,7 @@ def _sycl_include_path(repository_ctx, sycl_config, bash_bin):
 
 def enable_sycl(repository_ctx):
     """Returns whether to build with SYCL support."""
-    return int(get_host_environ(repository_ctx, "TF_NEED_SYCL", False))
+    return int(False)
 
 def auto_configure_fail(msg):
     """Output failure message when auto configuration fails."""
diff --git a/third_party/xla/third_party/py/rules_pywrap/pywrap.default.bzl b/third_party/xla/third_party/py/rules_pywrap/pywrap.default.bzl
index 9bbee965b57..39897ba2ef0 100644
--- a/third_party/xla/third_party/py/rules_pywrap/pywrap.default.bzl
+++ b/third_party/xla/third_party/py/rules_pywrap/pywrap.default.bzl
@@ -1,5 +1,4 @@
 # TODO(b/356020232): remove entire file and all usages after migration is done
-load("@python_version_repo//:py_version.bzl", "USE_PYWRAP_RULES")
 load(
     "//third_party/py/rules_pywrap:pywrap.impl.bzl",
     _pybind_extension = "pybind_extension",
@@ -91,7 +90,7 @@ def pybind_extension(
     )
 
 def use_pywrap_rules():
-    return USE_PYWRAP_RULES
+    return False
 
 def pywrap_library(name, **kwargs):
     if use_pywrap_rules():
diff --git a/third_party/xla/third_party/py/rules_pywrap/pywrap.impl.bzl b/third_party/xla/third_party/py/rules_pywrap/pywrap.impl.bzl
index 2f2f1906932..3ba3cdbf10a 100644
--- a/third_party/xla/third_party/py/rules_pywrap/pywrap.impl.bzl
+++ b/third_party/xla/third_party/py/rules_pywrap/pywrap.impl.bzl
@@ -131,222 +131,7 @@ def pywrap_library(
         testonly: The testonly argument of the resultant py_library target.
         compatible_with: The compatible_with of the py_library target.
     """
-
-    # 0) If pywrap_count is not specified, assume we pass pybind_extension,
-    # targets directly, so actual pywrap_count should just be equal to  number
-    # of deps.
-    actual_pywrap_count = len(deps) if pywrap_count == None else pywrap_count
-    if starlark_only_deps:
-        starlark_only_pywrap_count = len(starlark_only_deps)
-    actual_deps = deps + starlark_only_deps
-
-    # 1) Create common libraries cc-only (C API) and py-specific (parts reused
-    # by different pywrap libraries but dependin on Python symbols).
-    # The common library should link in everything except the object file with
-    # Python Extension's init function PyInit_<extension_name>.
-    info_collector_name = "_%s_info_collector" % name
-    collected_pywrap_infos(
-        name = info_collector_name,
-        deps = actual_deps,
-        pywrap_count = actual_pywrap_count,
-        starlark_only_pywrap_count = starlark_only_pywrap_count,
-    )
-
-    linker_input_filters_name = "_%s_linker_input_filters" % name
-
-    cur_pkg = native.package_name()
-    cur_pkg = cur_pkg + "/" if native.package_name() else cur_pkg
-    starlark_only_filter_full_name = None
-    if starlark_only_pywrap_count > 0:
-        starlark_only_filter_full_name = "%s%s__starlark_only_common" % (cur_pkg, name)
-
-    inverse_common_lib_filters = _construct_inverse_common_lib_filters(
-        common_lib_filters,
-    )
-
-    _linker_input_filters(
-        name = linker_input_filters_name,
-        dep = ":%s" % info_collector_name,
-        pywrap_lib_filter = pywrap_lib_filter,
-        pywrap_lib_exclusion_filter = pywrap_lib_exclusion_filter,
-        common_lib_filters = inverse_common_lib_filters,
-        starlark_only_filter_name = starlark_only_filter_full_name,
-        enable_common_lib_starlark_only_filter = enable_common_lib_starlark_only_filter,
-    )
-
-    common_deps = [] + extra_deps
-    starlark_only_common_deps = []
-    binaries_data = {}
-    starlark_only_binaries_data = {}
-    win_binaries_data = {}
-    win_starlark_only_binaries_data = {}
-    internal_binaries = []
-    win_internal_binaries = []
-
-    common_lib_full_names = []
-    common_lib_full_names.extend(common_lib_filters.keys())
-    common_lib_full_names.append("%s%s_common" % (cur_pkg, name))
-    if starlark_only_filter_full_name:
-        common_lib_full_names.append(starlark_only_filter_full_name)
-
-    for common_lib_full_name in common_lib_full_names:
-        common_lib_pkg, common_lib_name = _get_common_lib_package_and_name(
-            common_lib_full_name,
-        )
-        common_split_name = "_%s_split" % common_lib_name
-        _pywrap_common_split_library(
-            name = common_split_name,
-            dep = ":%s" % info_collector_name,
-            common_lib_full_name = common_lib_full_name,
-            linker_input_filters = "%s" % linker_input_filters_name,
-            testonly = testonly,
-            compatible_with = compatible_with,
-            collect_objects = select({
-                "@bazel_tools//src/conditions:windows": True,
-                "//conditions:default": False,
-            }),
-        )
-
-        win_def_name = "_%s_def" % common_lib_name
-        def_file_or_filter = common_lib_def_files_or_filters.get(
-            common_lib_full_name,
-            None,
-        )
-        generated_common_win_def_file(
-            name = win_def_name,
-            dep = ":%s" % common_split_name,
-            filter = def_file_or_filter,
-        )
-
-        linkopts = common_lib_linkopts.get(common_lib_full_name, [])
-        ver_script = common_lib_version_scripts.get(common_lib_full_name, None)
-        common_cc_binary_name = "%s" % common_lib_name
-
-        common_import_name, win_import_library_name = _construct_common_binary(
-            common_cc_binary_name,
-            common_deps + [":%s" % common_split_name],
-            linkopts,
-            testonly,
-            compatible_with,
-            ":%s" % win_def_name,
-            None,
-            binaries_data.values(),
-            common_lib_pkg,
-            ver_script,
-            [":%s" % common_split_name],
-            common_lib_versions.get(common_lib_full_name, ""),
-        )
-        actual_binaries_data = binaries_data
-        actual_common_deps = common_deps
-        actual_win_binaries_data = win_binaries_data
-        if common_lib_full_name == starlark_only_filter_full_name:
-            actual_binaries_data = starlark_only_binaries_data
-            actual_common_deps = starlark_only_common_deps
-            actual_win_binaries_data = win_starlark_only_binaries_data
-        internal_binaries.append(":%s" % common_cc_binary_name)
-        win_internal_binaries.append(":%s" % win_import_library_name)
-        actual_binaries_data[":%s" % common_cc_binary_name] = common_lib_pkg
-        actual_win_binaries_data[":%s" % win_import_library_name] = common_lib_pkg
-        actual_common_deps.append(":%s" % common_import_name)
-
-    # 2) Create individual super-thin pywrap libraries, which depend on the
-    # common one. The individual libraries must link in statically only the
-    # object file with Python Extension's init function PyInit_<extension_name>
-    #
-    shared_objects = []
-    for pywrap_index in range(0, actual_pywrap_count + starlark_only_pywrap_count):
-        dep_name = "_%s_%s" % (name, pywrap_index)
-        shared_object_name = "%s_shared_object" % dep_name
-        win_def_name = "%s_win_def" % dep_name
-        pywrap_name = "%s_pywrap" % dep_name
-
-        _pywrap_split_library(
-            name = pywrap_name,
-            dep = ":%s" % info_collector_name,
-            linker_input_filters = "%s" % linker_input_filters_name,
-            pywrap_index = pywrap_index,
-            testonly = testonly,
-            compatible_with = compatible_with,
-        )
-
-        _generated_win_def_file(
-            name = win_def_name,
-            dep = ":%s" % info_collector_name,
-            pywrap_index = pywrap_index,
-            testonly = testonly,
-            compatible_with = compatible_with,
-        )
-
-        actual_common_deps = common_deps
-        if pywrap_index >= actual_pywrap_count:
-            actual_common_deps = common_deps + starlark_only_common_deps
-
-        native.cc_binary(
-            name = shared_object_name,
-            srcs = [],
-            deps = [":%s" % pywrap_name] + actual_common_deps,
-            linkshared = True,
-            linkstatic = True,
-            win_def_file = ":%s" % win_def_name,
-            testonly = testonly,
-            compatible_with = compatible_with,
-        )
-        shared_objects.append(":%s" % shared_object_name)
-
-    # 3) Construct final binaries with proper names and put them as data
-    # attribute in a py_library, which is the final and only public artifact of
-    # this macro
-    #
-    pywrap_binaries_name = "%s_common_binaries" % name
-    wheel_locations_json_name = ":%s_wheel_locations.json" % pywrap_binaries_name
-
-    win_binaries_data.update(binaries_data)
-    win_starlark_only_binaries_data.update(starlark_only_binaries_data)
-
-    _pywrap_binaries(
-        name = pywrap_binaries_name,
-        collected_pywraps = ":%s" % info_collector_name,
-        deps = shared_objects,
-        common_binaries = select({
-            "@bazel_tools//src/conditions:windows": win_binaries_data,
-            "//conditions:default": binaries_data,
-        }),
-        starlark_only_common_binaries = select({
-            "@bazel_tools//src/conditions:windows": win_starlark_only_binaries_data,
-            "//conditions:default": starlark_only_binaries_data,
-        }),
-        extension = select({
-            "@bazel_tools//src/conditions:windows": ".pyd",
-            "//conditions:default": ".so",
-        }),
-        wheel_locations_json = wheel_locations_json_name,
-        testonly = testonly,
-        compatible_with = compatible_with,
-    )
-    internal_binaries.append(":%s" % pywrap_binaries_name)
-    internal_binaries.append(wheel_locations_json_name)
-
-    all_binaries_data = list(binaries_data.keys())
-    all_binaries_data.extend(starlark_only_binaries_data.keys())
-    all_binaries_data.append(":%s" % pywrap_binaries_name)
-    all_binaries_data.extend([shared_objects[-1]])
-
-    py_library(
-        name = name,
-        srcs = [":%s" % info_collector_name],
-        data = all_binaries_data,
-        testonly = testonly,
-        compatible_with = compatible_with,
-        visibility = visibility,
-    )
-
-    native.filegroup(
-        name = name + "_all_binaries",
-        srcs = select({
-            "@bazel_tools//src/conditions:windows": internal_binaries + win_internal_binaries,
-            "//conditions:default": internal_binaries,
-        }),
-    )
+    pass
 
 def _construct_common_binary(
         name,
@@ -1005,54 +790,11 @@ def pybind_extension(name, default_deps = None, **kwargs):
             dependency on pybind11 will be added.
         **kwargs: Additional arguments to pass to the python_extension.
     """
+    pass
 
-    actual_default_deps = ["@pybind11//:pybind11"]
-    if default_deps != None:
-        actual_default_deps = default_deps
-    python_extension(
-        name = name,
-        default_deps = actual_default_deps,
-        **kwargs
-    )
 
 def _pywrap_info_wrapper_impl(ctx):
-    #the attribute is called deps not dep to match aspect's attr_aspects
-    if len(ctx.attr.deps) != 1:
-        fail("deps attribute must contain exactly one dependency")
-
-    py_stub = ctx.actions.declare_file("%s.py" % ctx.attr.name)
-    substitutions = {}
-    py_pkgs = []
-    for pkg in ctx.attr.common_lib_packages:
-        if pkg:
-            py_pkgs.append(pkg.replace("/", ".") + "." + ctx.attr.name)
-
-    if py_pkgs:
-        val = "imports_paths = %s # template_val" % py_pkgs
-        substitutions["imports_paths = []  # template_val"] = val
-
-    ctx.actions.expand_template(
-        template = ctx.file.py_stub_src,
-        output = py_stub,
-        substitutions = substitutions,
-    )
-
-    default_runfiles = ctx.runfiles().merge(
-        ctx.attr.deps[0][DefaultInfo].default_runfiles,
-    )
-
-    return [
-        PyInfo(transitive_sources = depset()),
-        PywrapInfo(
-            cc_info = ctx.attr.deps[0][CcInfo],
-            default_runfiles = default_runfiles,
-            owner = ctx.label,
-            common_lib_packages = ctx.attr.common_lib_packages,
-            py_stub = py_stub,
-            cc_only = False,
-            starlark_only = ctx.attr.starlark_only,
-        ),
-    ]
+    pass
 
 _pywrap_info_wrapper = rule(
     attrs = {
diff --git a/third_party/xla/third_party/tensorrt/tensorrt_configure.bzl b/third_party/xla/third_party/tensorrt/tensorrt_configure.bzl
index 32c6d96f161..169df9b2a8b 100644
--- a/third_party/xla/third_party/tensorrt/tensorrt_configure.bzl
+++ b/third_party/xla/third_party/tensorrt/tensorrt_configure.bzl
@@ -154,7 +154,7 @@ def _create_dummy_repository(repository_ctx):
 
 def enable_tensorrt(repository_ctx):
     """Returns whether to build with TensorRT support."""
-    return int(get_host_environ(repository_ctx, _TF_NEED_TENSORRT, False))
+    return int(False)
 
 def _get_tensorrt_static_path(repository_ctx):
     """Returns the path for TensorRT static libraries."""
@@ -284,7 +284,7 @@ def _py_tmpl_dict(d):
 def _tensorrt_configure_impl(repository_ctx):
     """Implementation of the tensorrt_configure repository rule."""
 
-    if get_host_environ(repository_ctx, _TF_TENSORRT_CONFIG_REPO) != None:
+    if False:
         # Forward to the pre-configured remote repository.
         remote_config_repo = repository_ctx.os.environ[_TF_TENSORRT_CONFIG_REPO]
         repository_ctx.template("BUILD", config_repo_label(remote_config_repo, ":BUILD"), {})
