// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/carnot/planpb/plan.proto

package planpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	proto1 "pixielabs.ai/pixielabs/src/common/uuid/proto"
	proto2 "pixielabs.ai/pixielabs/src/shared/types/proto"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OperatorType int32

const (
	OPERATOR_TYPE_UNKNOWN  OperatorType = 0
	MEMORY_SOURCE_OPERATOR OperatorType = 1000
	GRPC_SOURCE_OPERATOR   OperatorType = 1100
	UDTF_SOURCE_OPERATOR   OperatorType = 1200
	MAP_OPERATOR           OperatorType = 2000
	AGGREGATE_OPERATOR     OperatorType = 2100
	FILTER_OPERATOR        OperatorType = 2200
	LIMIT_OPERATOR         OperatorType = 2300
	UNION_OPERATOR         OperatorType = 2400
	JOIN_OPERATOR          OperatorType = 2500
	MEMORY_SINK_OPERATOR   OperatorType = 9000
	GRPC_SINK_OPERATOR     OperatorType = 9100
)

var OperatorType_name = map[int32]string{
	0:    "OPERATOR_TYPE_UNKNOWN",
	1000: "MEMORY_SOURCE_OPERATOR",
	1100: "GRPC_SOURCE_OPERATOR",
	1200: "UDTF_SOURCE_OPERATOR",
	2000: "MAP_OPERATOR",
	2100: "AGGREGATE_OPERATOR",
	2200: "FILTER_OPERATOR",
	2300: "LIMIT_OPERATOR",
	2400: "UNION_OPERATOR",
	2500: "JOIN_OPERATOR",
	9000: "MEMORY_SINK_OPERATOR",
	9100: "GRPC_SINK_OPERATOR",
}

var OperatorType_value = map[string]int32{
	"OPERATOR_TYPE_UNKNOWN":  0,
	"MEMORY_SOURCE_OPERATOR": 1000,
	"GRPC_SOURCE_OPERATOR":   1100,
	"UDTF_SOURCE_OPERATOR":   1200,
	"MAP_OPERATOR":           2000,
	"AGGREGATE_OPERATOR":     2100,
	"FILTER_OPERATOR":        2200,
	"LIMIT_OPERATOR":         2300,
	"UNION_OPERATOR":         2400,
	"JOIN_OPERATOR":          2500,
	"MEMORY_SINK_OPERATOR":   9000,
	"GRPC_SINK_OPERATOR":     9100,
}

func (OperatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{0}
}

type JoinOperator_JoinType int32

const (
	INNER      JoinOperator_JoinType = 0
	LEFT_OUTER JoinOperator_JoinType = 1
	FULL_OUTER JoinOperator_JoinType = 3
)

var JoinOperator_JoinType_name = map[int32]string{
	0: "INNER",
	1: "LEFT_OUTER",
	3: "FULL_OUTER",
}

var JoinOperator_JoinType_value = map[string]int32{
	"INNER":      0,
	"LEFT_OUTER": 1,
	"FULL_OUTER": 3,
}

func (JoinOperator_JoinType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{15, 0}
}

type PlanOptions struct {
	Explain               bool  `protobuf:"varint,2,opt,name=explain,proto3" json:"explain,omitempty"`
	Analyze               bool  `protobuf:"varint,3,opt,name=analyze,proto3" json:"analyze,omitempty"`
	MaxOutputRowsPerTable int64 `protobuf:"varint,4,opt,name=max_output_rows_per_table,json=maxOutputRowsPerTable,proto3" json:"max_output_rows_per_table,omitempty"`
}

func (m *PlanOptions) Reset()      { *m = PlanOptions{} }
func (*PlanOptions) ProtoMessage() {}
func (*PlanOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{0}
}
func (m *PlanOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanOptions.Merge(m, src)
}
func (m *PlanOptions) XXX_Size() int {
	return m.Size()
}
func (m *PlanOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanOptions.DiscardUnknown(m)
}

var xxx_messageInfo_PlanOptions proto.InternalMessageInfo

func (m *PlanOptions) GetExplain() bool {
	if m != nil {
		return m.Explain
	}
	return false
}

func (m *PlanOptions) GetAnalyze() bool {
	if m != nil {
		return m.Analyze
	}
	return false
}

func (m *PlanOptions) GetMaxOutputRowsPerTable() int64 {
	if m != nil {
		return m.MaxOutputRowsPerTable
	}
	return 0
}

type Plan struct {
	Dag              *DAG            `protobuf:"bytes,1,opt,name=dag,proto3" json:"dag,omitempty"`
	Nodes            []*PlanFragment `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Distributed      bool            `protobuf:"varint,3,opt,name=distributed,proto3" json:"distributed,omitempty"` // Deprecated: Do not use.
	PlanOptions      *PlanOptions    `protobuf:"bytes,4,opt,name=plan_options,json=planOptions,proto3" json:"plan_options,omitempty"`
	IncomingAgentIDs []*proto1.UUID  `protobuf:"bytes,5,rep,name=incoming_agent_ids,json=incomingAgentIds,proto3" json:"incoming_agent_ids,omitempty"`
}

func (m *Plan) Reset()      { *m = Plan{} }
func (*Plan) ProtoMessage() {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{1}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.Size()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetDag() *DAG {
	if m != nil {
		return m.Dag
	}
	return nil
}

func (m *Plan) GetNodes() []*PlanFragment {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// Deprecated: Do not use.
func (m *Plan) GetDistributed() bool {
	if m != nil {
		return m.Distributed
	}
	return false
}

func (m *Plan) GetPlanOptions() *PlanOptions {
	if m != nil {
		return m.PlanOptions
	}
	return nil
}

func (m *Plan) GetIncomingAgentIDs() []*proto1.UUID {
	if m != nil {
		return m.IncomingAgentIDs
	}
	return nil
}

type PlanFragment struct {
	Id    uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Dag   *DAG        `protobuf:"bytes,2,opt,name=dag,proto3" json:"dag,omitempty"`
	Nodes []*PlanNode `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *PlanFragment) Reset()      { *m = PlanFragment{} }
func (*PlanFragment) ProtoMessage() {}
func (*PlanFragment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{2}
}
func (m *PlanFragment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanFragment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanFragment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanFragment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanFragment.Merge(m, src)
}
func (m *PlanFragment) XXX_Size() int {
	return m.Size()
}
func (m *PlanFragment) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanFragment.DiscardUnknown(m)
}

var xxx_messageInfo_PlanFragment proto.InternalMessageInfo

func (m *PlanFragment) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PlanFragment) GetDag() *DAG {
	if m != nil {
		return m.Dag
	}
	return nil
}

func (m *PlanFragment) GetNodes() []*PlanNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type DAG struct {
	Nodes []*DAG_DAGNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *DAG) Reset()      { *m = DAG{} }
func (*DAG) ProtoMessage() {}
func (*DAG) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{3}
}
func (m *DAG) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DAG) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DAG.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DAG) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DAG.Merge(m, src)
}
func (m *DAG) XXX_Size() int {
	return m.Size()
}
func (m *DAG) XXX_DiscardUnknown() {
	xxx_messageInfo_DAG.DiscardUnknown(m)
}

var xxx_messageInfo_DAG proto.InternalMessageInfo

func (m *DAG) GetNodes() []*DAG_DAGNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type DAG_DAGNode struct {
	Id             uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SortedParents  []uint64 `protobuf:"varint,4,rep,packed,name=sorted_parents,json=sortedParents,proto3" json:"sorted_parents,omitempty"`
	SortedChildren []uint64 `protobuf:"varint,3,rep,packed,name=sorted_children,json=sortedChildren,proto3" json:"sorted_children,omitempty"`
}

func (m *DAG_DAGNode) Reset()      { *m = DAG_DAGNode{} }
func (*DAG_DAGNode) ProtoMessage() {}
func (*DAG_DAGNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{3, 0}
}
func (m *DAG_DAGNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DAG_DAGNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DAG_DAGNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DAG_DAGNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DAG_DAGNode.Merge(m, src)
}
func (m *DAG_DAGNode) XXX_Size() int {
	return m.Size()
}
func (m *DAG_DAGNode) XXX_DiscardUnknown() {
	xxx_messageInfo_DAG_DAGNode.DiscardUnknown(m)
}

var xxx_messageInfo_DAG_DAGNode proto.InternalMessageInfo

func (m *DAG_DAGNode) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DAG_DAGNode) GetSortedParents() []uint64 {
	if m != nil {
		return m.SortedParents
	}
	return nil
}

func (m *DAG_DAGNode) GetSortedChildren() []uint64 {
	if m != nil {
		return m.SortedChildren
	}
	return nil
}

type PlanNode struct {
	Id uint64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Op *Operator `protobuf:"bytes,2,opt,name=op,proto3" json:"op,omitempty"`
}

func (m *PlanNode) Reset()      { *m = PlanNode{} }
func (*PlanNode) ProtoMessage() {}
func (*PlanNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{4}
}
func (m *PlanNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanNode.Merge(m, src)
}
func (m *PlanNode) XXX_Size() int {
	return m.Size()
}
func (m *PlanNode) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanNode.DiscardUnknown(m)
}

var xxx_messageInfo_PlanNode proto.InternalMessageInfo

func (m *PlanNode) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PlanNode) GetOp() *Operator {
	if m != nil {
		return m.Op
	}
	return nil
}

type Operator struct {
	OpType OperatorType `protobuf:"varint,1,opt,name=op_type,json=opType,proto3,enum=pl.carnot.planpb.OperatorType" json:"op_type,omitempty"`
	// Types that are valid to be assigned to Op:
	//	*Operator_MemSourceOp
	//	*Operator_MapOp
	//	*Operator_AggOp
	//	*Operator_MemSinkOp
	//	*Operator_FilterOp
	//	*Operator_LimitOp
	//	*Operator_UnionOp
	//	*Operator_GRPCSourceOp
	//	*Operator_GRPCSinkOp
	//	*Operator_JoinOp
	//	*Operator_UdtfSourceOp
	Op isOperator_Op `protobuf_oneof:"op"`
}

func (m *Operator) Reset()      { *m = Operator{} }
func (*Operator) ProtoMessage() {}
func (*Operator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{5}
}
func (m *Operator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Operator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Operator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Operator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operator.Merge(m, src)
}
func (m *Operator) XXX_Size() int {
	return m.Size()
}
func (m *Operator) XXX_DiscardUnknown() {
	xxx_messageInfo_Operator.DiscardUnknown(m)
}

var xxx_messageInfo_Operator proto.InternalMessageInfo

type isOperator_Op interface {
	isOperator_Op()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Operator_MemSourceOp struct {
	MemSourceOp *MemorySourceOperator `protobuf:"bytes,2,opt,name=mem_source_op,json=memSourceOp,proto3,oneof" json:"mem_source_op,omitempty"`
}
type Operator_MapOp struct {
	MapOp *MapOperator `protobuf:"bytes,3,opt,name=map_op,json=mapOp,proto3,oneof" json:"map_op,omitempty"`
}
type Operator_AggOp struct {
	AggOp *AggregateOperator `protobuf:"bytes,4,opt,name=agg_op,json=aggOp,proto3,oneof" json:"agg_op,omitempty"`
}
type Operator_MemSinkOp struct {
	MemSinkOp *MemorySinkOperator `protobuf:"bytes,5,opt,name=mem_sink_op,json=memSinkOp,proto3,oneof" json:"mem_sink_op,omitempty"`
}
type Operator_FilterOp struct {
	FilterOp *FilterOperator `protobuf:"bytes,6,opt,name=filter_op,json=filterOp,proto3,oneof" json:"filter_op,omitempty"`
}
type Operator_LimitOp struct {
	LimitOp *LimitOperator `protobuf:"bytes,7,opt,name=limit_op,json=limitOp,proto3,oneof" json:"limit_op,omitempty"`
}
type Operator_UnionOp struct {
	UnionOp *UnionOperator `protobuf:"bytes,8,opt,name=union_op,json=unionOp,proto3,oneof" json:"union_op,omitempty"`
}
type Operator_GRPCSourceOp struct {
	GRPCSourceOp *GRPCSourceOperator `protobuf:"bytes,9,opt,name=grpc_source_op,json=grpcSourceOp,proto3,oneof" json:"grpc_source_op,omitempty"`
}
type Operator_GRPCSinkOp struct {
	GRPCSinkOp *GRPCSinkOperator `protobuf:"bytes,1000,opt,name=grpc_sink_op,json=grpcSinkOp,proto3,oneof" json:"grpc_sink_op,omitempty"`
}
type Operator_JoinOp struct {
	JoinOp *JoinOperator `protobuf:"bytes,11,opt,name=join_op,json=joinOp,proto3,oneof" json:"join_op,omitempty"`
}
type Operator_UdtfSourceOp struct {
	UdtfSourceOp *UDTFSourceOperator `protobuf:"bytes,12,opt,name=udtf_source_op,json=udtfSourceOp,proto3,oneof" json:"udtf_source_op,omitempty"`
}

func (*Operator_MemSourceOp) isOperator_Op()  {}
func (*Operator_MapOp) isOperator_Op()        {}
func (*Operator_AggOp) isOperator_Op()        {}
func (*Operator_MemSinkOp) isOperator_Op()    {}
func (*Operator_FilterOp) isOperator_Op()     {}
func (*Operator_LimitOp) isOperator_Op()      {}
func (*Operator_UnionOp) isOperator_Op()      {}
func (*Operator_GRPCSourceOp) isOperator_Op() {}
func (*Operator_GRPCSinkOp) isOperator_Op()   {}
func (*Operator_JoinOp) isOperator_Op()       {}
func (*Operator_UdtfSourceOp) isOperator_Op() {}

func (m *Operator) GetOp() isOperator_Op {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *Operator) GetOpType() OperatorType {
	if m != nil {
		return m.OpType
	}
	return OPERATOR_TYPE_UNKNOWN
}

func (m *Operator) GetMemSourceOp() *MemorySourceOperator {
	if x, ok := m.GetOp().(*Operator_MemSourceOp); ok {
		return x.MemSourceOp
	}
	return nil
}

func (m *Operator) GetMapOp() *MapOperator {
	if x, ok := m.GetOp().(*Operator_MapOp); ok {
		return x.MapOp
	}
	return nil
}

func (m *Operator) GetAggOp() *AggregateOperator {
	if x, ok := m.GetOp().(*Operator_AggOp); ok {
		return x.AggOp
	}
	return nil
}

func (m *Operator) GetMemSinkOp() *MemorySinkOperator {
	if x, ok := m.GetOp().(*Operator_MemSinkOp); ok {
		return x.MemSinkOp
	}
	return nil
}

func (m *Operator) GetFilterOp() *FilterOperator {
	if x, ok := m.GetOp().(*Operator_FilterOp); ok {
		return x.FilterOp
	}
	return nil
}

func (m *Operator) GetLimitOp() *LimitOperator {
	if x, ok := m.GetOp().(*Operator_LimitOp); ok {
		return x.LimitOp
	}
	return nil
}

func (m *Operator) GetUnionOp() *UnionOperator {
	if x, ok := m.GetOp().(*Operator_UnionOp); ok {
		return x.UnionOp
	}
	return nil
}

func (m *Operator) GetGRPCSourceOp() *GRPCSourceOperator {
	if x, ok := m.GetOp().(*Operator_GRPCSourceOp); ok {
		return x.GRPCSourceOp
	}
	return nil
}

func (m *Operator) GetGRPCSinkOp() *GRPCSinkOperator {
	if x, ok := m.GetOp().(*Operator_GRPCSinkOp); ok {
		return x.GRPCSinkOp
	}
	return nil
}

func (m *Operator) GetJoinOp() *JoinOperator {
	if x, ok := m.GetOp().(*Operator_JoinOp); ok {
		return x.JoinOp
	}
	return nil
}

func (m *Operator) GetUdtfSourceOp() *UDTFSourceOperator {
	if x, ok := m.GetOp().(*Operator_UdtfSourceOp); ok {
		return x.UdtfSourceOp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Operator) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Operator_MemSourceOp)(nil),
		(*Operator_MapOp)(nil),
		(*Operator_AggOp)(nil),
		(*Operator_MemSinkOp)(nil),
		(*Operator_FilterOp)(nil),
		(*Operator_LimitOp)(nil),
		(*Operator_UnionOp)(nil),
		(*Operator_GRPCSourceOp)(nil),
		(*Operator_GRPCSinkOp)(nil),
		(*Operator_JoinOp)(nil),
		(*Operator_UdtfSourceOp)(nil),
	}
}

type MemorySourceOperator struct {
	Name        string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ColumnIdxs  []int64           `protobuf:"varint,2,rep,packed,name=column_idxs,json=columnIdxs,proto3" json:"column_idxs,omitempty"`
	ColumnNames []string          `protobuf:"bytes,3,rep,name=column_names,json=columnNames,proto3" json:"column_names,omitempty"`
	ColumnTypes []proto2.DataType `protobuf:"varint,4,rep,packed,name=column_types,json=columnTypes,proto3,enum=pl.types.DataType" json:"column_types,omitempty"`
	StartTime   *types.Int64Value `protobuf:"bytes,5,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	StopTime    *types.Int64Value `protobuf:"bytes,6,opt,name=stop_time,json=stopTime,proto3" json:"stop_time,omitempty"`
	Tablet      string            `protobuf:"bytes,7,opt,name=tablet,proto3" json:"tablet,omitempty"`
}

func (m *MemorySourceOperator) Reset()      { *m = MemorySourceOperator{} }
func (*MemorySourceOperator) ProtoMessage() {}
func (*MemorySourceOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{6}
}
func (m *MemorySourceOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemorySourceOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemorySourceOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemorySourceOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemorySourceOperator.Merge(m, src)
}
func (m *MemorySourceOperator) XXX_Size() int {
	return m.Size()
}
func (m *MemorySourceOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_MemorySourceOperator.DiscardUnknown(m)
}

var xxx_messageInfo_MemorySourceOperator proto.InternalMessageInfo

func (m *MemorySourceOperator) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MemorySourceOperator) GetColumnIdxs() []int64 {
	if m != nil {
		return m.ColumnIdxs
	}
	return nil
}

func (m *MemorySourceOperator) GetColumnNames() []string {
	if m != nil {
		return m.ColumnNames
	}
	return nil
}

func (m *MemorySourceOperator) GetColumnTypes() []proto2.DataType {
	if m != nil {
		return m.ColumnTypes
	}
	return nil
}

func (m *MemorySourceOperator) GetStartTime() *types.Int64Value {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *MemorySourceOperator) GetStopTime() *types.Int64Value {
	if m != nil {
		return m.StopTime
	}
	return nil
}

func (m *MemorySourceOperator) GetTablet() string {
	if m != nil {
		return m.Tablet
	}
	return ""
}

type MemorySinkOperator struct {
	Name                string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ColumnTypes         []proto2.DataType     `protobuf:"varint,2,rep,packed,name=column_types,json=columnTypes,proto3,enum=pl.types.DataType" json:"column_types,omitempty"`
	ColumnNames         []string              `protobuf:"bytes,3,rep,name=column_names,json=columnNames,proto3" json:"column_names,omitempty"`
	ColumnSemanticTypes []proto2.SemanticType `protobuf:"varint,4,rep,packed,name=column_semantic_types,json=columnSemanticTypes,proto3,enum=pl.types.SemanticType" json:"column_semantic_types,omitempty"`
}

func (m *MemorySinkOperator) Reset()      { *m = MemorySinkOperator{} }
func (*MemorySinkOperator) ProtoMessage() {}
func (*MemorySinkOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{7}
}
func (m *MemorySinkOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemorySinkOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemorySinkOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemorySinkOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemorySinkOperator.Merge(m, src)
}
func (m *MemorySinkOperator) XXX_Size() int {
	return m.Size()
}
func (m *MemorySinkOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_MemorySinkOperator.DiscardUnknown(m)
}

var xxx_messageInfo_MemorySinkOperator proto.InternalMessageInfo

func (m *MemorySinkOperator) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MemorySinkOperator) GetColumnTypes() []proto2.DataType {
	if m != nil {
		return m.ColumnTypes
	}
	return nil
}

func (m *MemorySinkOperator) GetColumnNames() []string {
	if m != nil {
		return m.ColumnNames
	}
	return nil
}

func (m *MemorySinkOperator) GetColumnSemanticTypes() []proto2.SemanticType {
	if m != nil {
		return m.ColumnSemanticTypes
	}
	return nil
}

type GRPCSourceOperator struct {
	ColumnTypes []proto2.DataType `protobuf:"varint,1,rep,packed,name=column_types,json=columnTypes,proto3,enum=pl.types.DataType" json:"column_types,omitempty"`
	ColumnNames []string          `protobuf:"bytes,2,rep,name=column_names,json=columnNames,proto3" json:"column_names,omitempty"`
}

func (m *GRPCSourceOperator) Reset()      { *m = GRPCSourceOperator{} }
func (*GRPCSourceOperator) ProtoMessage() {}
func (*GRPCSourceOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{8}
}
func (m *GRPCSourceOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRPCSourceOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRPCSourceOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRPCSourceOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRPCSourceOperator.Merge(m, src)
}
func (m *GRPCSourceOperator) XXX_Size() int {
	return m.Size()
}
func (m *GRPCSourceOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_GRPCSourceOperator.DiscardUnknown(m)
}

var xxx_messageInfo_GRPCSourceOperator proto.InternalMessageInfo

func (m *GRPCSourceOperator) GetColumnTypes() []proto2.DataType {
	if m != nil {
		return m.ColumnTypes
	}
	return nil
}

func (m *GRPCSourceOperator) GetColumnNames() []string {
	if m != nil {
		return m.ColumnNames
	}
	return nil
}

type GRPCSinkOperator struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Types that are valid to be assigned to Destination:
	//	*GRPCSinkOperator_GRPCSourceID
	//	*GRPCSinkOperator_TableName
	Destination isGRPCSinkOperator_Destination `protobuf_oneof:"destination"`
}

func (m *GRPCSinkOperator) Reset()      { *m = GRPCSinkOperator{} }
func (*GRPCSinkOperator) ProtoMessage() {}
func (*GRPCSinkOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{9}
}
func (m *GRPCSinkOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRPCSinkOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRPCSinkOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRPCSinkOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRPCSinkOperator.Merge(m, src)
}
func (m *GRPCSinkOperator) XXX_Size() int {
	return m.Size()
}
func (m *GRPCSinkOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_GRPCSinkOperator.DiscardUnknown(m)
}

var xxx_messageInfo_GRPCSinkOperator proto.InternalMessageInfo

type isGRPCSinkOperator_Destination interface {
	isGRPCSinkOperator_Destination()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GRPCSinkOperator_GRPCSourceID struct {
	GRPCSourceID uint64 `protobuf:"varint,3,opt,name=grpc_source_id,json=grpcSourceId,proto3,oneof" json:"grpc_source_id,omitempty"`
}
type GRPCSinkOperator_TableName struct {
	TableName string `protobuf:"bytes,4,opt,name=table_name,json=tableName,proto3,oneof" json:"table_name,omitempty"`
}

func (*GRPCSinkOperator_GRPCSourceID) isGRPCSinkOperator_Destination() {}
func (*GRPCSinkOperator_TableName) isGRPCSinkOperator_Destination()    {}

func (m *GRPCSinkOperator) GetDestination() isGRPCSinkOperator_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *GRPCSinkOperator) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GRPCSinkOperator) GetGRPCSourceID() uint64 {
	if x, ok := m.GetDestination().(*GRPCSinkOperator_GRPCSourceID); ok {
		return x.GRPCSourceID
	}
	return 0
}

func (m *GRPCSinkOperator) GetTableName() string {
	if x, ok := m.GetDestination().(*GRPCSinkOperator_TableName); ok {
		return x.TableName
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GRPCSinkOperator) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GRPCSinkOperator_GRPCSourceID)(nil),
		(*GRPCSinkOperator_TableName)(nil),
	}
}

type MapOperator struct {
	Expressions []*ScalarExpression `protobuf:"bytes,1,rep,name=expressions,proto3" json:"expressions,omitempty"`
	ColumnNames []string            `protobuf:"bytes,2,rep,name=column_names,json=columnNames,proto3" json:"column_names,omitempty"`
}

func (m *MapOperator) Reset()      { *m = MapOperator{} }
func (*MapOperator) ProtoMessage() {}
func (*MapOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{10}
}
func (m *MapOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapOperator.Merge(m, src)
}
func (m *MapOperator) XXX_Size() int {
	return m.Size()
}
func (m *MapOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_MapOperator.DiscardUnknown(m)
}

var xxx_messageInfo_MapOperator proto.InternalMessageInfo

func (m *MapOperator) GetExpressions() []*ScalarExpression {
	if m != nil {
		return m.Expressions
	}
	return nil
}

func (m *MapOperator) GetColumnNames() []string {
	if m != nil {
		return m.ColumnNames
	}
	return nil
}

type AggregateOperator struct {
	Values          []*AggregateExpression `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	Groups          []*Column              `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty"`
	GroupNames      []string               `protobuf:"bytes,3,rep,name=group_names,json=groupNames,proto3" json:"group_names,omitempty"`
	ValueNames      []string               `protobuf:"bytes,4,rep,name=value_names,json=valueNames,proto3" json:"value_names,omitempty"`
	Windowed        bool                   `protobuf:"varint,5,opt,name=windowed,proto3" json:"windowed,omitempty"`
	PartialAgg      bool                   `protobuf:"varint,6,opt,name=partial_agg,json=partialAgg,proto3" json:"partial_agg,omitempty"`
	FinalizeResults bool                   `protobuf:"varint,7,opt,name=finalize_results,json=finalizeResults,proto3" json:"finalize_results,omitempty"`
}

func (m *AggregateOperator) Reset()      { *m = AggregateOperator{} }
func (*AggregateOperator) ProtoMessage() {}
func (*AggregateOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{11}
}
func (m *AggregateOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateOperator.Merge(m, src)
}
func (m *AggregateOperator) XXX_Size() int {
	return m.Size()
}
func (m *AggregateOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateOperator.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateOperator proto.InternalMessageInfo

func (m *AggregateOperator) GetValues() []*AggregateExpression {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *AggregateOperator) GetGroups() []*Column {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *AggregateOperator) GetGroupNames() []string {
	if m != nil {
		return m.GroupNames
	}
	return nil
}

func (m *AggregateOperator) GetValueNames() []string {
	if m != nil {
		return m.ValueNames
	}
	return nil
}

func (m *AggregateOperator) GetWindowed() bool {
	if m != nil {
		return m.Windowed
	}
	return false
}

func (m *AggregateOperator) GetPartialAgg() bool {
	if m != nil {
		return m.PartialAgg
	}
	return false
}

func (m *AggregateOperator) GetFinalizeResults() bool {
	if m != nil {
		return m.FinalizeResults
	}
	return false
}

type FilterOperator struct {
	Expression *ScalarExpression `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
	Columns    []*Column         `protobuf:"bytes,2,rep,name=columns,proto3" json:"columns,omitempty"`
}

func (m *FilterOperator) Reset()      { *m = FilterOperator{} }
func (*FilterOperator) ProtoMessage() {}
func (*FilterOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{12}
}
func (m *FilterOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FilterOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FilterOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FilterOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FilterOperator.Merge(m, src)
}
func (m *FilterOperator) XXX_Size() int {
	return m.Size()
}
func (m *FilterOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_FilterOperator.DiscardUnknown(m)
}

var xxx_messageInfo_FilterOperator proto.InternalMessageInfo

func (m *FilterOperator) GetExpression() *ScalarExpression {
	if m != nil {
		return m.Expression
	}
	return nil
}

func (m *FilterOperator) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

type LimitOperator struct {
	Limit   int64     `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	Columns []*Column `protobuf:"bytes,2,rep,name=columns,proto3" json:"columns,omitempty"`
}

func (m *LimitOperator) Reset()      { *m = LimitOperator{} }
func (*LimitOperator) ProtoMessage() {}
func (*LimitOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{13}
}
func (m *LimitOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimitOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimitOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimitOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimitOperator.Merge(m, src)
}
func (m *LimitOperator) XXX_Size() int {
	return m.Size()
}
func (m *LimitOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_LimitOperator.DiscardUnknown(m)
}

var xxx_messageInfo_LimitOperator proto.InternalMessageInfo

func (m *LimitOperator) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *LimitOperator) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

type UnionOperator struct {
	ColumnNames    []string                       `protobuf:"bytes,1,rep,name=column_names,json=columnNames,proto3" json:"column_names,omitempty"`
	ColumnMappings []*UnionOperator_ColumnMapping `protobuf:"bytes,2,rep,name=column_mappings,json=columnMappings,proto3" json:"column_mappings,omitempty"`
	RowsPerBatch   uint64                         `protobuf:"varint,3,opt,name=rows_per_batch,json=rowsPerBatch,proto3" json:"rows_per_batch,omitempty"`
}

func (m *UnionOperator) Reset()      { *m = UnionOperator{} }
func (*UnionOperator) ProtoMessage() {}
func (*UnionOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{14}
}
func (m *UnionOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnionOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnionOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnionOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnionOperator.Merge(m, src)
}
func (m *UnionOperator) XXX_Size() int {
	return m.Size()
}
func (m *UnionOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_UnionOperator.DiscardUnknown(m)
}

var xxx_messageInfo_UnionOperator proto.InternalMessageInfo

func (m *UnionOperator) GetColumnNames() []string {
	if m != nil {
		return m.ColumnNames
	}
	return nil
}

func (m *UnionOperator) GetColumnMappings() []*UnionOperator_ColumnMapping {
	if m != nil {
		return m.ColumnMappings
	}
	return nil
}

func (m *UnionOperator) GetRowsPerBatch() uint64 {
	if m != nil {
		return m.RowsPerBatch
	}
	return 0
}

type UnionOperator_ColumnMapping struct {
	ColumnIndexes []int64 `protobuf:"varint,1,rep,packed,name=column_indexes,json=columnIndexes,proto3" json:"column_indexes,omitempty"`
}

func (m *UnionOperator_ColumnMapping) Reset()      { *m = UnionOperator_ColumnMapping{} }
func (*UnionOperator_ColumnMapping) ProtoMessage() {}
func (*UnionOperator_ColumnMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{14, 0}
}
func (m *UnionOperator_ColumnMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnionOperator_ColumnMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnionOperator_ColumnMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnionOperator_ColumnMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnionOperator_ColumnMapping.Merge(m, src)
}
func (m *UnionOperator_ColumnMapping) XXX_Size() int {
	return m.Size()
}
func (m *UnionOperator_ColumnMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_UnionOperator_ColumnMapping.DiscardUnknown(m)
}

var xxx_messageInfo_UnionOperator_ColumnMapping proto.InternalMessageInfo

func (m *UnionOperator_ColumnMapping) GetColumnIndexes() []int64 {
	if m != nil {
		return m.ColumnIndexes
	}
	return nil
}

type JoinOperator struct {
	Type               JoinOperator_JoinType             `protobuf:"varint,1,opt,name=type,proto3,enum=pl.carnot.planpb.JoinOperator_JoinType" json:"type,omitempty"`
	EqualityConditions []*JoinOperator_EqualityCondition `protobuf:"bytes,2,rep,name=equality_conditions,json=equalityConditions,proto3" json:"equality_conditions,omitempty"`
	OutputColumns      []*JoinOperator_ParentColumn      `protobuf:"bytes,3,rep,name=output_columns,json=outputColumns,proto3" json:"output_columns,omitempty"`
	ColumnNames        []string                          `protobuf:"bytes,4,rep,name=column_names,json=columnNames,proto3" json:"column_names,omitempty"`
	RowsPerBatch       uint64                            `protobuf:"varint,5,opt,name=rows_per_batch,json=rowsPerBatch,proto3" json:"rows_per_batch,omitempty"`
}

func (m *JoinOperator) Reset()      { *m = JoinOperator{} }
func (*JoinOperator) ProtoMessage() {}
func (*JoinOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{15}
}
func (m *JoinOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JoinOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JoinOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinOperator.Merge(m, src)
}
func (m *JoinOperator) XXX_Size() int {
	return m.Size()
}
func (m *JoinOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinOperator.DiscardUnknown(m)
}

var xxx_messageInfo_JoinOperator proto.InternalMessageInfo

func (m *JoinOperator) GetType() JoinOperator_JoinType {
	if m != nil {
		return m.Type
	}
	return INNER
}

func (m *JoinOperator) GetEqualityConditions() []*JoinOperator_EqualityCondition {
	if m != nil {
		return m.EqualityConditions
	}
	return nil
}

func (m *JoinOperator) GetOutputColumns() []*JoinOperator_ParentColumn {
	if m != nil {
		return m.OutputColumns
	}
	return nil
}

func (m *JoinOperator) GetColumnNames() []string {
	if m != nil {
		return m.ColumnNames
	}
	return nil
}

func (m *JoinOperator) GetRowsPerBatch() uint64 {
	if m != nil {
		return m.RowsPerBatch
	}
	return 0
}

type JoinOperator_EqualityCondition struct {
	LeftColumnIndex  uint64 `protobuf:"varint,1,opt,name=left_column_index,json=leftColumnIndex,proto3" json:"left_column_index,omitempty"`
	RightColumnIndex uint64 `protobuf:"varint,2,opt,name=right_column_index,json=rightColumnIndex,proto3" json:"right_column_index,omitempty"`
}

func (m *JoinOperator_EqualityCondition) Reset()      { *m = JoinOperator_EqualityCondition{} }
func (*JoinOperator_EqualityCondition) ProtoMessage() {}
func (*JoinOperator_EqualityCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{15, 0}
}
func (m *JoinOperator_EqualityCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinOperator_EqualityCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JoinOperator_EqualityCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JoinOperator_EqualityCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinOperator_EqualityCondition.Merge(m, src)
}
func (m *JoinOperator_EqualityCondition) XXX_Size() int {
	return m.Size()
}
func (m *JoinOperator_EqualityCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinOperator_EqualityCondition.DiscardUnknown(m)
}

var xxx_messageInfo_JoinOperator_EqualityCondition proto.InternalMessageInfo

func (m *JoinOperator_EqualityCondition) GetLeftColumnIndex() uint64 {
	if m != nil {
		return m.LeftColumnIndex
	}
	return 0
}

func (m *JoinOperator_EqualityCondition) GetRightColumnIndex() uint64 {
	if m != nil {
		return m.RightColumnIndex
	}
	return 0
}

type JoinOperator_ParentColumn struct {
	ParentIndex uint64 `protobuf:"varint,1,opt,name=parent_index,json=parentIndex,proto3" json:"parent_index,omitempty"`
	ColumnIndex uint64 `protobuf:"varint,2,opt,name=column_index,json=columnIndex,proto3" json:"column_index,omitempty"`
}

func (m *JoinOperator_ParentColumn) Reset()      { *m = JoinOperator_ParentColumn{} }
func (*JoinOperator_ParentColumn) ProtoMessage() {}
func (*JoinOperator_ParentColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{15, 1}
}
func (m *JoinOperator_ParentColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinOperator_ParentColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JoinOperator_ParentColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JoinOperator_ParentColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinOperator_ParentColumn.Merge(m, src)
}
func (m *JoinOperator_ParentColumn) XXX_Size() int {
	return m.Size()
}
func (m *JoinOperator_ParentColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinOperator_ParentColumn.DiscardUnknown(m)
}

var xxx_messageInfo_JoinOperator_ParentColumn proto.InternalMessageInfo

func (m *JoinOperator_ParentColumn) GetParentIndex() uint64 {
	if m != nil {
		return m.ParentIndex
	}
	return 0
}

func (m *JoinOperator_ParentColumn) GetColumnIndex() uint64 {
	if m != nil {
		return m.ColumnIndex
	}
	return 0
}

type UDTFSourceOperator struct {
	Name      string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ArgValues []*ScalarValue `protobuf:"bytes,2,rep,name=arg_values,json=argValues,proto3" json:"arg_values,omitempty"`
}

func (m *UDTFSourceOperator) Reset()      { *m = UDTFSourceOperator{} }
func (*UDTFSourceOperator) ProtoMessage() {}
func (*UDTFSourceOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{16}
}
func (m *UDTFSourceOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UDTFSourceOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UDTFSourceOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UDTFSourceOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UDTFSourceOperator.Merge(m, src)
}
func (m *UDTFSourceOperator) XXX_Size() int {
	return m.Size()
}
func (m *UDTFSourceOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_UDTFSourceOperator.DiscardUnknown(m)
}

var xxx_messageInfo_UDTFSourceOperator proto.InternalMessageInfo

func (m *UDTFSourceOperator) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UDTFSourceOperator) GetArgValues() []*ScalarValue {
	if m != nil {
		return m.ArgValues
	}
	return nil
}

type ScalarExpression struct {
	// Types that are valid to be assigned to Value:
	//	*ScalarExpression_Constant
	//	*ScalarExpression_Column
	//	*ScalarExpression_Func
	Value isScalarExpression_Value `protobuf_oneof:"value"`
}

func (m *ScalarExpression) Reset()      { *m = ScalarExpression{} }
func (*ScalarExpression) ProtoMessage() {}
func (*ScalarExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{17}
}
func (m *ScalarExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScalarExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScalarExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScalarExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScalarExpression.Merge(m, src)
}
func (m *ScalarExpression) XXX_Size() int {
	return m.Size()
}
func (m *ScalarExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ScalarExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ScalarExpression proto.InternalMessageInfo

type isScalarExpression_Value interface {
	isScalarExpression_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ScalarExpression_Constant struct {
	Constant *ScalarValue `protobuf:"bytes,1,opt,name=constant,proto3,oneof" json:"constant,omitempty"`
}
type ScalarExpression_Column struct {
	Column *Column `protobuf:"bytes,2,opt,name=column,proto3,oneof" json:"column,omitempty"`
}
type ScalarExpression_Func struct {
	Func *ScalarFunc `protobuf:"bytes,3,opt,name=func,proto3,oneof" json:"func,omitempty"`
}

func (*ScalarExpression_Constant) isScalarExpression_Value() {}
func (*ScalarExpression_Column) isScalarExpression_Value()   {}
func (*ScalarExpression_Func) isScalarExpression_Value()     {}

func (m *ScalarExpression) GetValue() isScalarExpression_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ScalarExpression) GetConstant() *ScalarValue {
	if x, ok := m.GetValue().(*ScalarExpression_Constant); ok {
		return x.Constant
	}
	return nil
}

func (m *ScalarExpression) GetColumn() *Column {
	if x, ok := m.GetValue().(*ScalarExpression_Column); ok {
		return x.Column
	}
	return nil
}

func (m *ScalarExpression) GetFunc() *ScalarFunc {
	if x, ok := m.GetValue().(*ScalarExpression_Func); ok {
		return x.Func
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScalarExpression) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScalarExpression_Constant)(nil),
		(*ScalarExpression_Column)(nil),
		(*ScalarExpression_Func)(nil),
	}
}

type ScalarValue struct {
	DataType proto2.DataType `protobuf:"varint,1,opt,name=data_type,json=dataType,proto3,enum=pl.types.DataType" json:"data_type,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*ScalarValue_BoolValue
	//	*ScalarValue_Int64Value
	//	*ScalarValue_Float64Value
	//	*ScalarValue_StringValue
	//	*ScalarValue_Time64NsValue
	//	*ScalarValue_Uint128Value
	Value isScalarValue_Value `protobuf_oneof:"value"`
}

func (m *ScalarValue) Reset()      { *m = ScalarValue{} }
func (*ScalarValue) ProtoMessage() {}
func (*ScalarValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{18}
}
func (m *ScalarValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScalarValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScalarValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScalarValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScalarValue.Merge(m, src)
}
func (m *ScalarValue) XXX_Size() int {
	return m.Size()
}
func (m *ScalarValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ScalarValue.DiscardUnknown(m)
}

var xxx_messageInfo_ScalarValue proto.InternalMessageInfo

type isScalarValue_Value interface {
	isScalarValue_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ScalarValue_BoolValue struct {
	BoolValue bool `protobuf:"varint,2,opt,name=bool_value,json=boolValue,proto3,oneof" json:"bool_value,omitempty"`
}
type ScalarValue_Int64Value struct {
	Int64Value int64 `protobuf:"varint,3,opt,name=int64_value,json=int64Value,proto3,oneof" json:"int64_value,omitempty"`
}
type ScalarValue_Float64Value struct {
	Float64Value float64 `protobuf:"fixed64,4,opt,name=float64_value,json=float64Value,proto3,oneof" json:"float64_value,omitempty"`
}
type ScalarValue_StringValue struct {
	StringValue string `protobuf:"bytes,5,opt,name=string_value,json=stringValue,proto3,oneof" json:"string_value,omitempty"`
}
type ScalarValue_Time64NsValue struct {
	Time64NsValue int64 `protobuf:"varint,6,opt,name=time64_ns_value,json=time64NsValue,proto3,oneof" json:"time64_ns_value,omitempty"`
}
type ScalarValue_Uint128Value struct {
	Uint128Value *proto2.UInt128 `protobuf:"bytes,7,opt,name=uint128_value,json=uint128Value,proto3,oneof" json:"uint128_value,omitempty"`
}

func (*ScalarValue_BoolValue) isScalarValue_Value()     {}
func (*ScalarValue_Int64Value) isScalarValue_Value()    {}
func (*ScalarValue_Float64Value) isScalarValue_Value()  {}
func (*ScalarValue_StringValue) isScalarValue_Value()   {}
func (*ScalarValue_Time64NsValue) isScalarValue_Value() {}
func (*ScalarValue_Uint128Value) isScalarValue_Value()  {}

func (m *ScalarValue) GetValue() isScalarValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ScalarValue) GetDataType() proto2.DataType {
	if m != nil {
		return m.DataType
	}
	return proto2.DATA_TYPE_UNKNOWN
}

func (m *ScalarValue) GetBoolValue() bool {
	if x, ok := m.GetValue().(*ScalarValue_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *ScalarValue) GetInt64Value() int64 {
	if x, ok := m.GetValue().(*ScalarValue_Int64Value); ok {
		return x.Int64Value
	}
	return 0
}

func (m *ScalarValue) GetFloat64Value() float64 {
	if x, ok := m.GetValue().(*ScalarValue_Float64Value); ok {
		return x.Float64Value
	}
	return 0
}

func (m *ScalarValue) GetStringValue() string {
	if x, ok := m.GetValue().(*ScalarValue_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *ScalarValue) GetTime64NsValue() int64 {
	if x, ok := m.GetValue().(*ScalarValue_Time64NsValue); ok {
		return x.Time64NsValue
	}
	return 0
}

func (m *ScalarValue) GetUint128Value() *proto2.UInt128 {
	if x, ok := m.GetValue().(*ScalarValue_Uint128Value); ok {
		return x.Uint128Value
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScalarValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScalarValue_BoolValue)(nil),
		(*ScalarValue_Int64Value)(nil),
		(*ScalarValue_Float64Value)(nil),
		(*ScalarValue_StringValue)(nil),
		(*ScalarValue_Time64NsValue)(nil),
		(*ScalarValue_Uint128Value)(nil),
	}
}

type ScalarFunc struct {
	Name          string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	InitArgs      []*ScalarValue      `protobuf:"bytes,2,rep,name=init_args,json=initArgs,proto3" json:"init_args,omitempty"`
	Args          []*ScalarExpression `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	Id            int64               `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	ArgsDataTypes []proto2.DataType   `protobuf:"varint,5,rep,packed,name=args_data_types,json=argsDataTypes,proto3,enum=pl.types.DataType" json:"args_data_types,omitempty"`
}

func (m *ScalarFunc) Reset()      { *m = ScalarFunc{} }
func (*ScalarFunc) ProtoMessage() {}
func (*ScalarFunc) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{19}
}
func (m *ScalarFunc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScalarFunc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScalarFunc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScalarFunc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScalarFunc.Merge(m, src)
}
func (m *ScalarFunc) XXX_Size() int {
	return m.Size()
}
func (m *ScalarFunc) XXX_DiscardUnknown() {
	xxx_messageInfo_ScalarFunc.DiscardUnknown(m)
}

var xxx_messageInfo_ScalarFunc proto.InternalMessageInfo

func (m *ScalarFunc) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ScalarFunc) GetInitArgs() []*ScalarValue {
	if m != nil {
		return m.InitArgs
	}
	return nil
}

func (m *ScalarFunc) GetArgs() []*ScalarExpression {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ScalarFunc) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ScalarFunc) GetArgsDataTypes() []proto2.DataType {
	if m != nil {
		return m.ArgsDataTypes
	}
	return nil
}

type AggregateExpression struct {
	Name          string                     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	InitArgs      []*ScalarValue             `protobuf:"bytes,4,rep,name=init_args,json=initArgs,proto3" json:"init_args,omitempty"`
	Args          []*AggregateExpression_Arg `protobuf:"bytes,5,rep,name=args,proto3" json:"args,omitempty"`
	Id            int64                      `protobuf:"varint,6,opt,name=id,proto3" json:"id,omitempty"`
	ArgsDataTypes []proto2.DataType          `protobuf:"varint,7,rep,packed,name=args_data_types,json=argsDataTypes,proto3,enum=pl.types.DataType" json:"args_data_types,omitempty"`
}

func (m *AggregateExpression) Reset()      { *m = AggregateExpression{} }
func (*AggregateExpression) ProtoMessage() {}
func (*AggregateExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{20}
}
func (m *AggregateExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateExpression.Merge(m, src)
}
func (m *AggregateExpression) XXX_Size() int {
	return m.Size()
}
func (m *AggregateExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateExpression.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateExpression proto.InternalMessageInfo

func (m *AggregateExpression) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AggregateExpression) GetInitArgs() []*ScalarValue {
	if m != nil {
		return m.InitArgs
	}
	return nil
}

func (m *AggregateExpression) GetArgs() []*AggregateExpression_Arg {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *AggregateExpression) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AggregateExpression) GetArgsDataTypes() []proto2.DataType {
	if m != nil {
		return m.ArgsDataTypes
	}
	return nil
}

type AggregateExpression_Arg struct {
	// Types that are valid to be assigned to Value:
	//	*AggregateExpression_Arg_Constant
	//	*AggregateExpression_Arg_Column
	Value isAggregateExpression_Arg_Value `protobuf_oneof:"value"`
}

func (m *AggregateExpression_Arg) Reset()      { *m = AggregateExpression_Arg{} }
func (*AggregateExpression_Arg) ProtoMessage() {}
func (*AggregateExpression_Arg) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{20, 0}
}
func (m *AggregateExpression_Arg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateExpression_Arg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateExpression_Arg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateExpression_Arg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateExpression_Arg.Merge(m, src)
}
func (m *AggregateExpression_Arg) XXX_Size() int {
	return m.Size()
}
func (m *AggregateExpression_Arg) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateExpression_Arg.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateExpression_Arg proto.InternalMessageInfo

type isAggregateExpression_Arg_Value interface {
	isAggregateExpression_Arg_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AggregateExpression_Arg_Constant struct {
	Constant *ScalarValue `protobuf:"bytes,1,opt,name=constant,proto3,oneof" json:"constant,omitempty"`
}
type AggregateExpression_Arg_Column struct {
	Column *Column `protobuf:"bytes,2,opt,name=column,proto3,oneof" json:"column,omitempty"`
}

func (*AggregateExpression_Arg_Constant) isAggregateExpression_Arg_Value() {}
func (*AggregateExpression_Arg_Column) isAggregateExpression_Arg_Value()   {}

func (m *AggregateExpression_Arg) GetValue() isAggregateExpression_Arg_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AggregateExpression_Arg) GetConstant() *ScalarValue {
	if x, ok := m.GetValue().(*AggregateExpression_Arg_Constant); ok {
		return x.Constant
	}
	return nil
}

func (m *AggregateExpression_Arg) GetColumn() *Column {
	if x, ok := m.GetValue().(*AggregateExpression_Arg_Column); ok {
		return x.Column
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AggregateExpression_Arg) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AggregateExpression_Arg_Constant)(nil),
		(*AggregateExpression_Arg_Column)(nil),
	}
}

type Column struct {
	Node  uint64 `protobuf:"varint,1,opt,name=node,proto3" json:"node,omitempty"`
	Index uint64 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *Column) Reset()      { *m = Column{} }
func (*Column) ProtoMessage() {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5dcfc8666ec3f33, []int{21}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetNode() uint64 {
	if m != nil {
		return m.Node
	}
	return 0
}

func (m *Column) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func init() {
	proto.RegisterEnum("pl.carnot.planpb.OperatorType", OperatorType_name, OperatorType_value)
	proto.RegisterEnum("pl.carnot.planpb.JoinOperator_JoinType", JoinOperator_JoinType_name, JoinOperator_JoinType_value)
	proto.RegisterType((*PlanOptions)(nil), "pl.carnot.planpb.PlanOptions")
	proto.RegisterType((*Plan)(nil), "pl.carnot.planpb.Plan")
	proto.RegisterType((*PlanFragment)(nil), "pl.carnot.planpb.PlanFragment")
	proto.RegisterType((*DAG)(nil), "pl.carnot.planpb.DAG")
	proto.RegisterType((*DAG_DAGNode)(nil), "pl.carnot.planpb.DAG.DAGNode")
	proto.RegisterType((*PlanNode)(nil), "pl.carnot.planpb.PlanNode")
	proto.RegisterType((*Operator)(nil), "pl.carnot.planpb.Operator")
	proto.RegisterType((*MemorySourceOperator)(nil), "pl.carnot.planpb.MemorySourceOperator")
	proto.RegisterType((*MemorySinkOperator)(nil), "pl.carnot.planpb.MemorySinkOperator")
	proto.RegisterType((*GRPCSourceOperator)(nil), "pl.carnot.planpb.GRPCSourceOperator")
	proto.RegisterType((*GRPCSinkOperator)(nil), "pl.carnot.planpb.GRPCSinkOperator")
	proto.RegisterType((*MapOperator)(nil), "pl.carnot.planpb.MapOperator")
	proto.RegisterType((*AggregateOperator)(nil), "pl.carnot.planpb.AggregateOperator")
	proto.RegisterType((*FilterOperator)(nil), "pl.carnot.planpb.FilterOperator")
	proto.RegisterType((*LimitOperator)(nil), "pl.carnot.planpb.LimitOperator")
	proto.RegisterType((*UnionOperator)(nil), "pl.carnot.planpb.UnionOperator")
	proto.RegisterType((*UnionOperator_ColumnMapping)(nil), "pl.carnot.planpb.UnionOperator.ColumnMapping")
	proto.RegisterType((*JoinOperator)(nil), "pl.carnot.planpb.JoinOperator")
	proto.RegisterType((*JoinOperator_EqualityCondition)(nil), "pl.carnot.planpb.JoinOperator.EqualityCondition")
	proto.RegisterType((*JoinOperator_ParentColumn)(nil), "pl.carnot.planpb.JoinOperator.ParentColumn")
	proto.RegisterType((*UDTFSourceOperator)(nil), "pl.carnot.planpb.UDTFSourceOperator")
	proto.RegisterType((*ScalarExpression)(nil), "pl.carnot.planpb.ScalarExpression")
	proto.RegisterType((*ScalarValue)(nil), "pl.carnot.planpb.ScalarValue")
	proto.RegisterType((*ScalarFunc)(nil), "pl.carnot.planpb.ScalarFunc")
	proto.RegisterType((*AggregateExpression)(nil), "pl.carnot.planpb.AggregateExpression")
	proto.RegisterType((*AggregateExpression_Arg)(nil), "pl.carnot.planpb.AggregateExpression.Arg")
	proto.RegisterType((*Column)(nil), "pl.carnot.planpb.Column")
}

func init() { proto.RegisterFile("src/carnot/planpb/plan.proto", fileDescriptor_e5dcfc8666ec3f33) }

var fileDescriptor_e5dcfc8666ec3f33 = []byte{
	// 2203 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x92, 0x14, 0xb5, 0x7c, 0xfc, 0x10, 0x35, 0xb6, 0x53, 0x59, 0x49, 0x28, 0x65, 0x13,
	0xd7, 0x8a, 0xdb, 0x50, 0xae, 0xe2, 0xb8, 0xae, 0xe3, 0xa0, 0xa5, 0x24, 0x4a, 0xa6, 0x22, 0x91,
	0xc2, 0x98, 0x4a, 0xe0, 0x1e, 0xba, 0x18, 0x71, 0x57, 0xeb, 0x49, 0xf6, 0xab, 0xbb, 0xcb, 0x48,
	0xca, 0xa5, 0xed, 0xad, 0x87, 0x1e, 0x7a, 0xec, 0xa1, 0xa7, 0x02, 0x05, 0x72, 0x2a, 0x02, 0xb4,
	0x7f, 0x40, 0x0b, 0x14, 0x68, 0x0f, 0x45, 0xe1, 0x43, 0x0f, 0x39, 0x19, 0xb6, 0x7c, 0xf1, 0x31,
	0xbd, 0xf7, 0x50, 0xcc, 0xc7, 0x8a, 0x4b, 0x2d, 0x69, 0xa9, 0x39, 0xf4, 0x20, 0x68, 0xe7, 0x37,
	0xbf, 0xf7, 0xe6, 0xbd, 0x37, 0x33, 0xef, 0xbd, 0x21, 0xbc, 0x16, 0x06, 0xfd, 0xe5, 0x3e, 0x09,
	0x5c, 0x2f, 0x5a, 0xf6, 0x6d, 0xe2, 0xfa, 0xfb, 0xfc, 0x5f, 0xc3, 0x0f, 0xbc, 0xc8, 0x43, 0x35,
	0xdf, 0x6e, 0x88, 0xc9, 0x86, 0x98, 0x9c, 0xaf, 0x5b, 0x9e, 0x67, 0xd9, 0xe6, 0x32, 0x9f, 0xdf,
	0x1f, 0x1c, 0x2c, 0x1f, 0x06, 0xc4, 0xf7, 0xcd, 0x20, 0x14, 0x12, 0xf3, 0x1a, 0xd3, 0x17, 0x3e,
	0x22, 0x81, 0x69, 0x2c, 0x47, 0xc7, 0xbe, 0x19, 0x0a, 0xa6, 0xf8, 0x96, 0x9c, 0x77, 0x2c, 0x1a,
	0x3d, 0x1a, 0xec, 0x37, 0xfa, 0x9e, 0xb3, 0x6c, 0x79, 0x96, 0x37, 0x54, 0xc6, 0x46, 0x82, 0xcf,
	0xbe, 0x24, 0x7d, 0x91, 0x9b, 0xe8, 0x39, 0x8e, 0xe7, 0x2e, 0x0f, 0x06, 0xd4, 0x90, 0x1a, 0xd9,
	0xa7, 0x60, 0x68, 0xbf, 0x50, 0xa0, 0xb4, 0x6b, 0x13, 0xb7, 0xeb, 0x47, 0xd4, 0x73, 0x43, 0x34,
	0x07, 0xd3, 0xe6, 0x91, 0x6f, 0x13, 0xea, 0xce, 0x65, 0x17, 0x95, 0x25, 0x15, 0xc7, 0x43, 0x36,
	0x43, 0x5c, 0x62, 0x1f, 0x7f, 0x6e, 0xce, 0xe5, 0xc4, 0x8c, 0x1c, 0xa2, 0x3b, 0x70, 0xd5, 0x21,
	0x47, 0xba, 0x37, 0x88, 0xfc, 0x41, 0xa4, 0x07, 0xde, 0x61, 0xa8, 0xfb, 0x66, 0xa0, 0x47, 0x64,
	0xdf, 0x36, 0xe7, 0xf2, 0x8b, 0xca, 0x52, 0x0e, 0x5f, 0x71, 0xc8, 0x51, 0x97, 0xcf, 0x63, 0xef,
	0x30, 0xdc, 0x35, 0x83, 0x1e, 0x9b, 0xdc, 0xca, 0xab, 0x4a, 0x2d, 0xab, 0xfd, 0x2e, 0x0b, 0x79,
	0x66, 0x03, 0xba, 0x0e, 0x39, 0x83, 0x58, 0x73, 0xca, 0xa2, 0xb2, 0x54, 0x5a, 0xb9, 0xd2, 0x38,
	0x1b, 0xc1, 0xc6, 0x7a, 0x73, 0x13, 0x33, 0x06, 0xba, 0x05, 0x53, 0xae, 0x67, 0x98, 0xe1, 0x5c,
	0x76, 0x31, 0xb7, 0x54, 0x5a, 0xa9, 0xa7, 0xa9, 0x4c, 0xdf, 0x46, 0x40, 0x2c, 0xc7, 0x74, 0x23,
	0x2c, 0xc8, 0xe8, 0x2d, 0x28, 0x19, 0x34, 0x8c, 0x02, 0xba, 0x3f, 0x88, 0x4c, 0x43, 0x78, 0xb1,
	0x9a, 0x9d, 0x53, 0x70, 0x12, 0x46, 0x3f, 0x82, 0x32, 0xd3, 0xa1, 0x7b, 0x22, 0x22, 0xdc, 0x81,
	0xd2, 0xca, 0xeb, 0xe3, 0x97, 0x90, 0x61, 0xc3, 0x25, 0x3f, 0x11, 0xc3, 0x07, 0x80, 0xa8, 0xdb,
	0xf7, 0x1c, 0xea, 0x5a, 0x3a, 0xb1, 0x4c, 0x37, 0xd2, 0xa9, 0x11, 0xce, 0x4d, 0x71, 0x53, 0x67,
	0x98, 0x1e, 0x16, 0x7f, 0x7f, 0xbf, 0xb1, 0xb7, 0xd7, 0x5e, 0x5f, 0xbd, 0x7c, 0xf2, 0x64, 0xa1,
	0xd6, 0x96, 0xf4, 0x26, 0x63, 0xb7, 0xd7, 0x43, 0x5c, 0xa3, 0x23, 0x88, 0x11, 0x6a, 0xc7, 0x50,
	0x4e, 0xfa, 0x84, 0xaa, 0x90, 0xa5, 0x06, 0x0f, 0x55, 0x1e, 0x67, 0xa9, 0x11, 0xc7, 0x2e, 0x7b,
	0x6e, 0xec, 0x6e, 0xc6, 0xb1, 0xcb, 0x71, 0x83, 0xe6, 0xc7, 0x3b, 0xd6, 0xf1, 0x0c, 0x53, 0xc6,
	0x4d, 0xfb, 0xbd, 0x02, 0xb9, 0xf5, 0xe6, 0x26, 0x7a, 0x37, 0x96, 0x54, 0xb8, 0xe4, 0xeb, 0x63,
	0x17, 0x61, 0x7f, 0x09, 0xe1, 0x79, 0x0a, 0xd3, 0x12, 0x49, 0x99, 0x7c, 0x0d, 0xaa, 0xa1, 0x17,
	0x44, 0xa6, 0xa1, 0xfb, 0x24, 0x30, 0xdd, 0x88, 0xc5, 0x3a, 0xb7, 0x94, 0xc7, 0x15, 0x81, 0xee,
	0x0a, 0x10, 0x5d, 0x87, 0x19, 0x49, 0xeb, 0x3f, 0xa2, 0xb6, 0x11, 0x98, 0x2e, 0x37, 0x3d, 0x8f,
	0xa5, 0xf4, 0x9a, 0x44, 0xb5, 0x0d, 0x50, 0x63, 0xd3, 0x53, 0x6b, 0xdd, 0x80, 0xac, 0xe7, 0xcb,
	0xe8, 0x8c, 0x71, 0xb9, 0xeb, 0x9b, 0x01, 0x89, 0xbc, 0x00, 0x67, 0x3d, 0x5f, 0xfb, 0x57, 0x01,
	0xd4, 0x18, 0x40, 0xdf, 0x87, 0x69, 0xcf, 0xd7, 0xd9, 0x1d, 0xe4, 0xda, 0xaa, 0xe3, 0x0e, 0x5b,
	0x4c, 0xee, 0x1d, 0xfb, 0x26, 0x2e, 0x78, 0x3e, 0xfb, 0x8f, 0xb6, 0xa1, 0xe2, 0x98, 0x8e, 0x1e,
	0x7a, 0x83, 0xa0, 0x6f, 0xea, 0xa7, 0x8b, 0x7f, 0x3b, 0x2d, 0xbe, 0x63, 0x3a, 0x5e, 0x70, 0xfc,
	0x80, 0x13, 0x63, 0x55, 0xf7, 0x33, 0xb8, 0xe4, 0x98, 0x4e, 0x0c, 0xa2, 0xdb, 0x50, 0x70, 0x88,
	0xcf, 0xd4, 0xe4, 0x26, 0x9d, 0xc7, 0x1d, 0xe2, 0x27, 0xa4, 0xa7, 0x1c, 0x36, 0x44, 0xf7, 0xa0,
	0x40, 0x2c, 0x8b, 0xc9, 0x89, 0x73, 0xfc, 0x66, 0x5a, 0xae, 0x69, 0x59, 0x81, 0x69, 0x91, 0x28,
	0xb9, 0xf6, 0x14, 0xb1, 0xac, 0xae, 0x8f, 0x36, 0xa0, 0xc4, 0x7d, 0xa0, 0xee, 0xa7, 0x4c, 0xc5,
	0x14, 0x57, 0xf1, 0xd6, 0x44, 0x0f, 0xa8, 0xfb, 0x69, 0x42, 0x47, 0x91, 0xd9, 0xcf, 0x21, 0xf4,
	0x43, 0x28, 0x1e, 0x50, 0x3b, 0x32, 0x03, 0xa6, 0xa5, 0xc0, 0xb5, 0x2c, 0xa6, 0xb5, 0x6c, 0x70,
	0x4a, 0x42, 0x83, 0x7a, 0x20, 0x11, 0x74, 0x0f, 0x54, 0x9b, 0x3a, 0x34, 0x62, 0xf2, 0xd3, 0x5c,
	0x7e, 0x21, 0x2d, 0xbf, 0xcd, 0x18, 0x09, 0xf1, 0x69, 0x5b, 0x00, 0x4c, 0x7a, 0xe0, 0x52, 0x8f,
	0xdd, 0xe9, 0x39, 0x75, 0x92, 0xf4, 0x1e, 0x63, 0x24, 0xa5, 0x07, 0x02, 0x40, 0x3f, 0x81, 0xaa,
	0x15, 0xf8, 0xfd, 0xc4, 0x4e, 0x16, 0x27, 0xc5, 0x61, 0x13, 0xef, 0xae, 0x8d, 0xee, 0xe3, 0x6a,
	0xed, 0xe4, 0xc9, 0x42, 0x39, 0x89, 0xdf, 0xcf, 0xe0, 0x32, 0xd3, 0x77, 0xba, 0xb5, 0x1f, 0x43,
	0x59, 0xe8, 0x97, 0x51, 0x7e, 0x21, 0x1c, 0xd4, 0x26, 0xa8, 0x4f, 0x04, 0x79, 0xb5, 0x7a, 0xf2,
	0x64, 0x01, 0x86, 0xe8, 0xfd, 0x0c, 0x06, 0xae, 0x5a, 0x44, 0xfd, 0x07, 0x30, 0xfd, 0x89, 0x47,
	0xb9, 0xd7, 0x25, 0xae, 0x72, 0xcc, 0xd1, 0xdd, 0xf2, 0x68, 0xd2, 0xe9, 0xc2, 0x27, 0x7c, 0x8c,
	0xb6, 0xa1, 0x3a, 0x30, 0xa2, 0x83, 0x84, 0xcf, 0xe5, 0x49, 0x3e, 0xef, 0xad, 0xf7, 0x36, 0x52,
	0x67, 0xb7, 0xcc, 0xa4, 0x63, 0x74, 0x35, 0xcf, 0x2e, 0x9f, 0xf6, 0xc7, 0x2c, 0x5c, 0x1e, 0x77,
	0xd4, 0x11, 0x82, 0xbc, 0x4b, 0x1c, 0x71, 0xbf, 0x8a, 0x98, 0x7f, 0xa3, 0x05, 0x28, 0xf5, 0x3d,
	0x7b, 0xe0, 0xb8, 0x3a, 0x35, 0x8e, 0x44, 0x9e, 0xcf, 0x61, 0x10, 0x50, 0xdb, 0x38, 0x0a, 0xd1,
	0x1b, 0x50, 0x96, 0x04, 0xc6, 0x17, 0xd9, 0xac, 0x88, 0xa5, 0x50, 0x87, 0x41, 0xe8, 0xbd, 0x53,
	0x0a, 0x2f, 0xa1, 0x3c, 0xbb, 0x54, 0x57, 0x10, 0x73, 0x41, 0xd4, 0xd4, 0x75, 0x12, 0x11, 0x7e,
	0x67, 0xa5, 0x18, 0xfb, 0x0e, 0xd1, 0x5d, 0x80, 0x30, 0x22, 0x41, 0xa4, 0x47, 0xd4, 0x31, 0xe5,
	0x99, 0x7f, 0xb5, 0x21, 0x8a, 0x77, 0x23, 0xae, 0xb7, 0x8d, 0xb6, 0x1b, 0xdd, 0xbe, 0xf5, 0x11,
	0xb1, 0x07, 0x26, 0x2e, 0x72, 0x7a, 0x8f, 0x3a, 0xac, 0x14, 0x16, 0xc3, 0x88, 0xe5, 0x0b, 0x26,
	0x5a, 0x38, 0x5f, 0x54, 0x65, 0x6c, 0x2e, 0xf9, 0x0a, 0x14, 0x78, 0xc1, 0x8c, 0xf8, 0xf9, 0x2e,
	0x62, 0x39, 0xd2, 0xfe, 0xa9, 0x00, 0x4a, 0x5f, 0xaf, 0xb1, 0x31, 0x3b, 0xeb, 0x6f, 0xf6, 0x62,
	0xfe, 0x5e, 0x20, 0x92, 0x5b, 0x70, 0x45, 0x52, 0x42, 0xd3, 0x21, 0x6e, 0x44, 0xfb, 0x23, 0x21,
	0x7d, 0x65, 0xb8, 0xc4, 0x03, 0x39, 0xcf, 0x97, 0xb9, 0x24, 0x84, 0x92, 0x58, 0xa8, 0xb9, 0x80,
	0xd2, 0xd7, 0x24, 0x65, 0xbb, 0xf2, 0xcd, 0x6c, 0xcf, 0xa6, 0x6c, 0xd7, 0x7e, 0xab, 0x40, 0xed,
	0xec, 0xc5, 0xe1, 0xcd, 0x8c, 0x61, 0x04, 0x66, 0x18, 0xca, 0x08, 0xc6, 0x43, 0x74, 0x67, 0xf4,
	0xb6, 0x53, 0xd1, 0x27, 0xe4, 0xcf, 0xde, 0xe3, 0xf6, 0xfa, 0xe8, 0x3d, 0x6e, 0x1b, 0x68, 0x01,
	0x80, 0xef, 0x19, 0x37, 0x85, 0xa7, 0xdb, 0x22, 0xcb, 0x82, 0x1c, 0x63, 0xa6, 0xac, 0x56, 0xa0,
	0x64, 0x98, 0x61, 0x44, 0x5d, 0xc2, 0xfa, 0x84, 0xad, 0xbc, 0x9a, 0xad, 0xe5, 0xb4, 0xcf, 0xa0,
	0x94, 0x48, 0xdc, 0x68, 0x1d, 0x4a, 0xe6, 0x91, 0xcf, 0x2c, 0xe1, 0xcd, 0x87, 0xa8, 0xb4, 0x63,
	0x52, 0xc1, 0x83, 0x3e, 0xb1, 0x49, 0xd0, 0x3a, 0xa5, 0xe2, 0xa4, 0xd8, 0x45, 0xc2, 0xf2, 0x87,
	0x2c, 0xcc, 0xa6, 0x32, 0x3f, 0xfa, 0x00, 0x0a, 0x9f, 0xb1, 0x83, 0x19, 0xaf, 0x7c, 0xed, 0x25,
	0xe5, 0x22, 0xb1, 0xb8, 0x14, 0x42, 0x37, 0xa1, 0x60, 0x05, 0xde, 0xc0, 0x8f, 0x1b, 0xb3, 0xb9,
	0xb4, 0xf8, 0x1a, 0xb7, 0x01, 0x4b, 0x1e, 0xbb, 0xe7, 0xfc, 0x6b, 0xe4, 0xec, 0x01, 0x87, 0xc4,
	0xd1, 0x5b, 0x80, 0x12, 0x57, 0x2e, 0x09, 0x79, 0x41, 0xe0, 0x90, 0x20, 0xcc, 0x83, 0x7a, 0x48,
	0x5d, 0xc3, 0x3b, 0x34, 0x0d, 0x7e, 0x59, 0x55, 0x7c, 0x3a, 0x66, 0xc2, 0x3e, 0x09, 0x22, 0x4a,
	0x6c, 0x9d, 0x58, 0x16, 0xbf, 0x90, 0x2a, 0x06, 0x09, 0x35, 0x2d, 0x0b, 0xbd, 0x0d, 0xb5, 0x03,
	0xea, 0x12, 0x9b, 0x7e, 0x6e, 0xea, 0x81, 0x19, 0x0e, 0xec, 0x28, 0xe4, 0xf7, 0x4f, 0xc5, 0x33,
	0x31, 0x8e, 0x05, 0xac, 0xfd, 0x52, 0x81, 0xea, 0x68, 0x85, 0x42, 0xab, 0x00, 0xc3, 0xa8, 0xcb,
	0xb6, 0xf5, 0x22, 0x7b, 0x95, 0x90, 0x42, 0x2b, 0x30, 0x2d, 0xb6, 0xe5, 0xfc, 0x98, 0xc5, 0x44,
	0xed, 0x21, 0x54, 0x46, 0x6a, 0x1d, 0xba, 0x0c, 0x53, 0xbc, 0xd6, 0x71, 0x1b, 0x72, 0x58, 0x0c,
	0xbe, 0x91, 0xea, 0x17, 0x0a, 0x54, 0x46, 0x2a, 0x61, 0xea, 0x2c, 0x29, 0xe9, 0xf4, 0xf0, 0x11,
	0xcc, 0x48, 0x8a, 0x43, 0x7c, 0x9f, 0xba, 0x56, 0xbc, 0xe0, 0x3b, 0xe7, 0x94, 0x59, 0xb9, 0xfc,
	0x8e, 0x90, 0xc2, 0xd5, 0x7e, 0x72, 0xc8, 0x1a, 0xf6, 0xea, 0xe9, 0x6b, 0x62, 0x9f, 0x44, 0xfd,
	0x47, 0xe2, 0x2e, 0xe2, 0x72, 0x20, 0x1e, 0x11, 0xab, 0x0c, 0x9b, 0xbf, 0x0d, 0x95, 0x11, 0x35,
	0xac, 0xaf, 0x8c, 0x6b, 0x87, 0x6b, 0x98, 0x47, 0xd2, 0xe6, 0x1c, 0xae, 0xc8, 0xf2, 0x21, 0x40,
	0xed, 0x6f, 0x79, 0x28, 0x27, 0xcb, 0x1f, 0x7a, 0x1f, 0xf2, 0x89, 0x3e, 0xef, 0xfa, 0xcb, 0x8b,
	0x25, 0x1f, 0xf0, 0x84, 0xc4, 0x85, 0x10, 0x81, 0x4b, 0xe6, 0x4f, 0x07, 0xc4, 0xa6, 0xd1, 0xb1,
	0xde, 0xf7, 0x5c, 0x83, 0x8a, 0xd7, 0x83, 0x88, 0xc3, 0xcd, 0x73, 0x74, 0xb5, 0xa4, 0xe4, 0x5a,
	0x2c, 0x88, 0x91, 0x79, 0x16, 0x0a, 0x11, 0x86, 0xaa, 0x7c, 0x63, 0xc5, 0xdb, 0x2a, 0x5a, 0xf8,
	0xef, 0x9c, 0xa3, 0x5d, 0x34, 0xd2, 0x72, 0xa7, 0x2b, 0x42, 0x85, 0x18, 0xa5, 0x33, 0x45, 0x3e,
	0xbd, 0xbb, 0xe9, 0x5d, 0x98, 0x1a, 0xb3, 0x0b, 0x0e, 0xcc, 0xa6, 0xbc, 0x40, 0x37, 0x60, 0xd6,
	0x36, 0x0f, 0x62, 0x7b, 0xc5, 0x76, 0xc8, 0xa6, 0x7c, 0x86, 0x4d, 0xac, 0x0d, 0x37, 0x04, 0x7d,
	0x17, 0x50, 0x40, 0xad, 0x47, 0x67, 0xc8, 0x59, 0x4e, 0xae, 0xf1, 0x99, 0x04, 0x7b, 0xbe, 0x07,
	0xe5, 0xa4, 0x5b, 0xcc, 0x0f, 0xf1, 0x88, 0x18, 0x59, 0xa4, 0x24, 0x30, 0xb1, 0xc0, 0xd0, 0xd5,
	0xa4, 0xea, 0x52, 0xe2, 0x50, 0x68, 0xef, 0x81, 0x1a, 0x6f, 0x2b, 0x2a, 0xc2, 0x54, 0xbb, 0xd3,
	0x69, 0xe1, 0x5a, 0x06, 0x55, 0x01, 0xb6, 0x5b, 0x1b, 0x3d, 0xbd, 0xbb, 0xd7, 0x6b, 0xe1, 0x9a,
	0xc2, 0xc6, 0x1b, 0x7b, 0xdb, 0xdb, 0x72, 0x9c, 0xd3, 0x0e, 0x00, 0xa5, 0xbb, 0xa0, 0xb1, 0x25,
	0xfa, 0x1e, 0x00, 0x09, 0x2c, 0x5d, 0xe6, 0xd8, 0xec, 0xa4, 0x77, 0x94, 0xc8, 0x18, 0xb2, 0xbb,
	0x20, 0x81, 0xc5, 0xbf, 0x42, 0xed, 0xcf, 0x0a, 0xd4, 0xce, 0x26, 0x13, 0xf4, 0x3e, 0xa8, 0x7d,
	0xcf, 0x0d, 0x23, 0xe2, 0x46, 0x32, 0x05, 0xbd, 0x5c, 0x21, 0xeb, 0xab, 0x63, 0x01, 0xb4, 0x02,
	0x05, 0xe1, 0xbf, 0x7c, 0x9d, 0x4c, 0xcc, 0x10, 0xac, 0x37, 0x14, 0x4c, 0xb4, 0x02, 0xf9, 0x83,
	0x81, 0xdb, 0x97, 0x0f, 0x91, 0xd7, 0x26, 0x2d, 0xb6, 0x31, 0x70, 0xfb, 0xf7, 0x33, 0x98, 0x73,
	0x57, 0xa7, 0x61, 0x8a, 0xfb, 0xac, 0xfd, 0x25, 0x0b, 0xa5, 0x84, 0x31, 0x68, 0x19, 0x8a, 0x06,
	0x89, 0x48, 0xf2, 0x81, 0x35, 0xae, 0xe8, 0xab, 0x86, 0xfc, 0x62, 0x55, 0x76, 0xdf, 0xf3, 0x6c,
	0x11, 0x42, 0xf1, 0x1b, 0x05, 0xab, 0xb2, 0x0c, 0x13, 0x1a, 0xdf, 0x80, 0x12, 0x65, 0x0d, 0x96,
	0x64, 0x30, 0x2b, 0x73, 0xac, 0x31, 0xa6, 0xa7, 0x5d, 0x17, 0xba, 0x06, 0x95, 0x03, 0xdb, 0x23,
	0x43, 0x12, 0x2b, 0xd6, 0x0a, 0x2b, 0xe8, 0x12, 0x16, 0xb4, 0x37, 0xa1, 0x1c, 0x46, 0x01, 0x7b,
	0xc5, 0x0b, 0xd6, 0x94, 0x2c, 0xe9, 0x25, 0x81, 0x0a, 0xd2, 0x12, 0xcc, 0xb0, 0x66, 0xef, 0xf6,
	0x2d, 0xdd, 0x0d, 0x25, 0xaf, 0x20, 0x97, 0xac, 0x88, 0x89, 0x4e, 0x28, 0x98, 0x77, 0xa0, 0x32,
	0xa0, 0x6e, 0xf4, 0xbd, 0x95, 0x3b, 0x92, 0x27, 0xfa, 0xfc, 0xd9, 0xa1, 0xbb, 0x7b, 0x6d, 0x3e,
	0xcd, 0xfb, 0x67, 0xc1, 0xe4, 0x92, 0xa7, 0xd1, 0xdb, 0xca, 0xab, 0x6a, 0xad, 0xa8, 0x3d, 0x55,
	0x00, 0x86, 0x31, 0x1e, 0x7b, 0xce, 0xee, 0x42, 0x91, 0xba, 0x34, 0xd2, 0x49, 0x60, 0x5d, 0xf0,
	0x98, 0xa9, 0x8c, 0xdf, 0x0c, 0xac, 0x10, 0xdd, 0x86, 0x3c, 0x17, 0xcb, 0x5d, 0xb8, 0xf7, 0xe0,
	0x7c, 0xf9, 0xe4, 0x16, 0xbf, 0xf7, 0xb0, 0x27, 0xf7, 0x5d, 0x98, 0x61, 0xb8, 0x7e, 0xba, 0xbf,
	0xe2, 0x37, 0x90, 0xf1, 0x1b, 0x5c, 0x61, 0xd4, 0x78, 0x14, 0x6a, 0xff, 0xce, 0xc2, 0xa5, 0x31,
	0x8d, 0xc6, 0xa9, 0xaf, 0xb9, 0x49, 0xbe, 0xe6, 0xff, 0x37, 0x5f, 0x3f, 0x90, 0xbe, 0x8a, 0x1f,
	0x67, 0xde, 0xbe, 0x50, 0xb7, 0xd3, 0x68, 0x06, 0xd6, 0x88, 0xcb, 0x85, 0x97, 0xb9, 0x3c, 0x7d,
	0x41, 0x97, 0xe7, 0x7f, 0x06, 0xb9, 0x66, 0x60, 0xfd, 0xdf, 0xaf, 0xf3, 0xf0, 0x6a, 0xae, 0x40,
	0x41, 0x26, 0x53, 0x16, 0x65, 0xcf, 0x30, 0x65, 0x12, 0xe5, 0xdf, 0xac, 0xc5, 0x48, 0xa6, 0x4d,
	0x31, 0xb8, 0xf1, 0x65, 0x16, 0xca, 0xc9, 0x5f, 0x3f, 0xd0, 0x55, 0xb8, 0xd2, 0xdd, 0x6d, 0xe1,
	0x66, 0xaf, 0x8b, 0xf5, 0xde, 0xc3, 0xdd, 0x96, 0xbe, 0xd7, 0xf9, 0xb0, 0xd3, 0xfd, 0xb8, 0x53,
	0xcb, 0xa0, 0x57, 0xe1, 0x95, 0x9d, 0xd6, 0x4e, 0x17, 0x3f, 0xd4, 0x1f, 0x74, 0xf7, 0xf0, 0x5a,
	0x4b, 0x8f, 0x89, 0xb5, 0x17, 0xd3, 0xe8, 0x2a, 0x5c, 0x66, 0xcd, 0x75, 0x6a, 0xea, 0x1f, 0x2a,
	0x9b, 0x62, 0xd9, 0x35, 0x35, 0xf5, 0x65, 0x11, 0xcd, 0x42, 0x79, 0xa7, 0xb9, 0x3b, 0x84, 0x1e,
	0xcf, 0xa0, 0x6f, 0x01, 0x6a, 0x6e, 0x6e, 0xe2, 0xd6, 0x66, 0xb3, 0x97, 0xe0, 0xfe, 0xa9, 0x86,
	0x2e, 0xc3, 0xcc, 0x46, 0x7b, 0xbb, 0xd7, 0xc2, 0x43, 0xf4, 0x37, 0xb3, 0xe8, 0x12, 0x54, 0xb7,
	0xdb, 0x3b, 0xed, 0xde, 0x10, 0xfc, 0x0f, 0x07, 0xf7, 0x3a, 0xed, 0x6e, 0x67, 0x08, 0x3e, 0x45,
	0x08, 0x41, 0x65, 0xab, 0xdb, 0x4e, 0x60, 0x7f, 0xbd, 0xc4, 0x4c, 0x8b, 0x5d, 0x6a, 0x77, 0x3e,
	0x1c, 0x4e, 0x7d, 0xb1, 0xc1, 0xec, 0x10, 0x0e, 0x8d, 0x4c, 0xfc, 0x6a, 0x73, 0xf5, 0xde, 0xe3,
	0x67, 0xf5, 0xcc, 0x57, 0xcf, 0xea, 0x99, 0xaf, 0x9f, 0xd5, 0x95, 0x9f, 0x9f, 0xd4, 0x95, 0x2f,
	0x4e, 0xea, 0xca, 0xdf, 0x4f, 0xea, 0xca, 0xe3, 0x93, 0xba, 0xf2, 0xf4, 0xa4, 0xae, 0xbc, 0x38,
	0xa9, 0x67, 0xbe, 0x3e, 0xa9, 0x2b, 0xbf, 0x7e, 0x5e, 0xcf, 0x3c, 0x7e, 0x5e, 0xcf, 0x7c, 0xf5,
	0xbc, 0x9e, 0xf9, 0x71, 0x41, 0x6c, 0xdf, 0x7e, 0x81, 0xbf, 0x22, 0xdf, 0xfd, 0x6f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x92, 0x15, 0xc7, 0xb0, 0x7d, 0x16, 0x00, 0x00,
}

func (x OperatorType) String() string {
	s, ok := OperatorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x JoinOperator_JoinType) String() string {
	s, ok := JoinOperator_JoinType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *PlanOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanOptions)
	if !ok {
		that2, ok := that.(PlanOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Explain != that1.Explain {
		return false
	}
	if this.Analyze != that1.Analyze {
		return false
	}
	if this.MaxOutputRowsPerTable != that1.MaxOutputRowsPerTable {
		return false
	}
	return true
}
func (this *Plan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Plan)
	if !ok {
		that2, ok := that.(Plan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dag.Equal(that1.Dag) {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	if this.Distributed != that1.Distributed {
		return false
	}
	if !this.PlanOptions.Equal(that1.PlanOptions) {
		return false
	}
	if len(this.IncomingAgentIDs) != len(that1.IncomingAgentIDs) {
		return false
	}
	for i := range this.IncomingAgentIDs {
		if !this.IncomingAgentIDs[i].Equal(that1.IncomingAgentIDs[i]) {
			return false
		}
	}
	return true
}
func (this *PlanFragment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanFragment)
	if !ok {
		that2, ok := that.(PlanFragment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Dag.Equal(that1.Dag) {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	return true
}
func (this *DAG) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DAG)
	if !ok {
		that2, ok := that.(DAG)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	return true
}
func (this *DAG_DAGNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DAG_DAGNode)
	if !ok {
		that2, ok := that.(DAG_DAGNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.SortedParents) != len(that1.SortedParents) {
		return false
	}
	for i := range this.SortedParents {
		if this.SortedParents[i] != that1.SortedParents[i] {
			return false
		}
	}
	if len(this.SortedChildren) != len(that1.SortedChildren) {
		return false
	}
	for i := range this.SortedChildren {
		if this.SortedChildren[i] != that1.SortedChildren[i] {
			return false
		}
	}
	return true
}
func (this *PlanNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode)
	if !ok {
		that2, ok := that.(PlanNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Op.Equal(that1.Op) {
		return false
	}
	return true
}
func (this *Operator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator)
	if !ok {
		that2, ok := that.(Operator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OpType != that1.OpType {
		return false
	}
	if that1.Op == nil {
		if this.Op != nil {
			return false
		}
	} else if this.Op == nil {
		return false
	} else if !this.Op.Equal(that1.Op) {
		return false
	}
	return true
}
func (this *Operator_MemSourceOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_MemSourceOp)
	if !ok {
		that2, ok := that.(Operator_MemSourceOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MemSourceOp.Equal(that1.MemSourceOp) {
		return false
	}
	return true
}
func (this *Operator_MapOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_MapOp)
	if !ok {
		that2, ok := that.(Operator_MapOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MapOp.Equal(that1.MapOp) {
		return false
	}
	return true
}
func (this *Operator_AggOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_AggOp)
	if !ok {
		that2, ok := that.(Operator_AggOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AggOp.Equal(that1.AggOp) {
		return false
	}
	return true
}
func (this *Operator_MemSinkOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_MemSinkOp)
	if !ok {
		that2, ok := that.(Operator_MemSinkOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MemSinkOp.Equal(that1.MemSinkOp) {
		return false
	}
	return true
}
func (this *Operator_FilterOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_FilterOp)
	if !ok {
		that2, ok := that.(Operator_FilterOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FilterOp.Equal(that1.FilterOp) {
		return false
	}
	return true
}
func (this *Operator_LimitOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_LimitOp)
	if !ok {
		that2, ok := that.(Operator_LimitOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LimitOp.Equal(that1.LimitOp) {
		return false
	}
	return true
}
func (this *Operator_UnionOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_UnionOp)
	if !ok {
		that2, ok := that.(Operator_UnionOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UnionOp.Equal(that1.UnionOp) {
		return false
	}
	return true
}
func (this *Operator_GRPCSourceOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_GRPCSourceOp)
	if !ok {
		that2, ok := that.(Operator_GRPCSourceOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GRPCSourceOp.Equal(that1.GRPCSourceOp) {
		return false
	}
	return true
}
func (this *Operator_GRPCSinkOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_GRPCSinkOp)
	if !ok {
		that2, ok := that.(Operator_GRPCSinkOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GRPCSinkOp.Equal(that1.GRPCSinkOp) {
		return false
	}
	return true
}
func (this *Operator_JoinOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_JoinOp)
	if !ok {
		that2, ok := that.(Operator_JoinOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JoinOp.Equal(that1.JoinOp) {
		return false
	}
	return true
}
func (this *Operator_UdtfSourceOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Operator_UdtfSourceOp)
	if !ok {
		that2, ok := that.(Operator_UdtfSourceOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UdtfSourceOp.Equal(that1.UdtfSourceOp) {
		return false
	}
	return true
}
func (this *MemorySourceOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MemorySourceOperator)
	if !ok {
		that2, ok := that.(MemorySourceOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.ColumnIdxs) != len(that1.ColumnIdxs) {
		return false
	}
	for i := range this.ColumnIdxs {
		if this.ColumnIdxs[i] != that1.ColumnIdxs[i] {
			return false
		}
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	if len(this.ColumnTypes) != len(that1.ColumnTypes) {
		return false
	}
	for i := range this.ColumnTypes {
		if this.ColumnTypes[i] != that1.ColumnTypes[i] {
			return false
		}
	}
	if !this.StartTime.Equal(that1.StartTime) {
		return false
	}
	if !this.StopTime.Equal(that1.StopTime) {
		return false
	}
	if this.Tablet != that1.Tablet {
		return false
	}
	return true
}
func (this *MemorySinkOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MemorySinkOperator)
	if !ok {
		that2, ok := that.(MemorySinkOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.ColumnTypes) != len(that1.ColumnTypes) {
		return false
	}
	for i := range this.ColumnTypes {
		if this.ColumnTypes[i] != that1.ColumnTypes[i] {
			return false
		}
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	if len(this.ColumnSemanticTypes) != len(that1.ColumnSemanticTypes) {
		return false
	}
	for i := range this.ColumnSemanticTypes {
		if this.ColumnSemanticTypes[i] != that1.ColumnSemanticTypes[i] {
			return false
		}
	}
	return true
}
func (this *GRPCSourceOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GRPCSourceOperator)
	if !ok {
		that2, ok := that.(GRPCSourceOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ColumnTypes) != len(that1.ColumnTypes) {
		return false
	}
	for i := range this.ColumnTypes {
		if this.ColumnTypes[i] != that1.ColumnTypes[i] {
			return false
		}
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	return true
}
func (this *GRPCSinkOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GRPCSinkOperator)
	if !ok {
		that2, ok := that.(GRPCSinkOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if that1.Destination == nil {
		if this.Destination != nil {
			return false
		}
	} else if this.Destination == nil {
		return false
	} else if !this.Destination.Equal(that1.Destination) {
		return false
	}
	return true
}
func (this *GRPCSinkOperator_GRPCSourceID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GRPCSinkOperator_GRPCSourceID)
	if !ok {
		that2, ok := that.(GRPCSinkOperator_GRPCSourceID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GRPCSourceID != that1.GRPCSourceID {
		return false
	}
	return true
}
func (this *GRPCSinkOperator_TableName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GRPCSinkOperator_TableName)
	if !ok {
		that2, ok := that.(GRPCSinkOperator_TableName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableName != that1.TableName {
		return false
	}
	return true
}
func (this *MapOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MapOperator)
	if !ok {
		that2, ok := that.(MapOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Expressions) != len(that1.Expressions) {
		return false
	}
	for i := range this.Expressions {
		if !this.Expressions[i].Equal(that1.Expressions[i]) {
			return false
		}
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	return true
}
func (this *AggregateOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateOperator)
	if !ok {
		that2, ok := that.(AggregateOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !this.Values[i].Equal(that1.Values[i]) {
			return false
		}
	}
	if len(this.Groups) != len(that1.Groups) {
		return false
	}
	for i := range this.Groups {
		if !this.Groups[i].Equal(that1.Groups[i]) {
			return false
		}
	}
	if len(this.GroupNames) != len(that1.GroupNames) {
		return false
	}
	for i := range this.GroupNames {
		if this.GroupNames[i] != that1.GroupNames[i] {
			return false
		}
	}
	if len(this.ValueNames) != len(that1.ValueNames) {
		return false
	}
	for i := range this.ValueNames {
		if this.ValueNames[i] != that1.ValueNames[i] {
			return false
		}
	}
	if this.Windowed != that1.Windowed {
		return false
	}
	if this.PartialAgg != that1.PartialAgg {
		return false
	}
	if this.FinalizeResults != that1.FinalizeResults {
		return false
	}
	return true
}
func (this *FilterOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FilterOperator)
	if !ok {
		that2, ok := that.(FilterOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Expression.Equal(that1.Expression) {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	return true
}
func (this *LimitOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LimitOperator)
	if !ok {
		that2, ok := that.(LimitOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	return true
}
func (this *UnionOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UnionOperator)
	if !ok {
		that2, ok := that.(UnionOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	if len(this.ColumnMappings) != len(that1.ColumnMappings) {
		return false
	}
	for i := range this.ColumnMappings {
		if !this.ColumnMappings[i].Equal(that1.ColumnMappings[i]) {
			return false
		}
	}
	if this.RowsPerBatch != that1.RowsPerBatch {
		return false
	}
	return true
}
func (this *UnionOperator_ColumnMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UnionOperator_ColumnMapping)
	if !ok {
		that2, ok := that.(UnionOperator_ColumnMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ColumnIndexes) != len(that1.ColumnIndexes) {
		return false
	}
	for i := range this.ColumnIndexes {
		if this.ColumnIndexes[i] != that1.ColumnIndexes[i] {
			return false
		}
	}
	return true
}
func (this *JoinOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JoinOperator)
	if !ok {
		that2, ok := that.(JoinOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.EqualityConditions) != len(that1.EqualityConditions) {
		return false
	}
	for i := range this.EqualityConditions {
		if !this.EqualityConditions[i].Equal(that1.EqualityConditions[i]) {
			return false
		}
	}
	if len(this.OutputColumns) != len(that1.OutputColumns) {
		return false
	}
	for i := range this.OutputColumns {
		if !this.OutputColumns[i].Equal(that1.OutputColumns[i]) {
			return false
		}
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	if this.RowsPerBatch != that1.RowsPerBatch {
		return false
	}
	return true
}
func (this *JoinOperator_EqualityCondition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JoinOperator_EqualityCondition)
	if !ok {
		that2, ok := that.(JoinOperator_EqualityCondition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LeftColumnIndex != that1.LeftColumnIndex {
		return false
	}
	if this.RightColumnIndex != that1.RightColumnIndex {
		return false
	}
	return true
}
func (this *JoinOperator_ParentColumn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JoinOperator_ParentColumn)
	if !ok {
		that2, ok := that.(JoinOperator_ParentColumn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ParentIndex != that1.ParentIndex {
		return false
	}
	if this.ColumnIndex != that1.ColumnIndex {
		return false
	}
	return true
}
func (this *UDTFSourceOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UDTFSourceOperator)
	if !ok {
		that2, ok := that.(UDTFSourceOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.ArgValues) != len(that1.ArgValues) {
		return false
	}
	for i := range this.ArgValues {
		if !this.ArgValues[i].Equal(that1.ArgValues[i]) {
			return false
		}
	}
	return true
}
func (this *ScalarExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarExpression)
	if !ok {
		that2, ok := that.(ScalarExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *ScalarExpression_Constant) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarExpression_Constant)
	if !ok {
		that2, ok := that.(ScalarExpression_Constant)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Constant.Equal(that1.Constant) {
		return false
	}
	return true
}
func (this *ScalarExpression_Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarExpression_Column)
	if !ok {
		that2, ok := that.(ScalarExpression_Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	return true
}
func (this *ScalarExpression_Func) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarExpression_Func)
	if !ok {
		that2, ok := that.(ScalarExpression_Func)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Func.Equal(that1.Func) {
		return false
	}
	return true
}
func (this *ScalarValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarValue)
	if !ok {
		that2, ok := that.(ScalarValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataType != that1.DataType {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *ScalarValue_BoolValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarValue_BoolValue)
	if !ok {
		that2, ok := that.(ScalarValue_BoolValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BoolValue != that1.BoolValue {
		return false
	}
	return true
}
func (this *ScalarValue_Int64Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarValue_Int64Value)
	if !ok {
		that2, ok := that.(ScalarValue_Int64Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int64Value != that1.Int64Value {
		return false
	}
	return true
}
func (this *ScalarValue_Float64Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarValue_Float64Value)
	if !ok {
		that2, ok := that.(ScalarValue_Float64Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Float64Value != that1.Float64Value {
		return false
	}
	return true
}
func (this *ScalarValue_StringValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarValue_StringValue)
	if !ok {
		that2, ok := that.(ScalarValue_StringValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StringValue != that1.StringValue {
		return false
	}
	return true
}
func (this *ScalarValue_Time64NsValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarValue_Time64NsValue)
	if !ok {
		that2, ok := that.(ScalarValue_Time64NsValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Time64NsValue != that1.Time64NsValue {
		return false
	}
	return true
}
func (this *ScalarValue_Uint128Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarValue_Uint128Value)
	if !ok {
		that2, ok := that.(ScalarValue_Uint128Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Uint128Value.Equal(that1.Uint128Value) {
		return false
	}
	return true
}
func (this *ScalarFunc) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarFunc)
	if !ok {
		that2, ok := that.(ScalarFunc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.InitArgs) != len(that1.InitArgs) {
		return false
	}
	for i := range this.InitArgs {
		if !this.InitArgs[i].Equal(that1.InitArgs[i]) {
			return false
		}
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if !this.Args[i].Equal(that1.Args[i]) {
			return false
		}
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.ArgsDataTypes) != len(that1.ArgsDataTypes) {
		return false
	}
	for i := range this.ArgsDataTypes {
		if this.ArgsDataTypes[i] != that1.ArgsDataTypes[i] {
			return false
		}
	}
	return true
}
func (this *AggregateExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateExpression)
	if !ok {
		that2, ok := that.(AggregateExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.InitArgs) != len(that1.InitArgs) {
		return false
	}
	for i := range this.InitArgs {
		if !this.InitArgs[i].Equal(that1.InitArgs[i]) {
			return false
		}
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if !this.Args[i].Equal(that1.Args[i]) {
			return false
		}
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.ArgsDataTypes) != len(that1.ArgsDataTypes) {
		return false
	}
	for i := range this.ArgsDataTypes {
		if this.ArgsDataTypes[i] != that1.ArgsDataTypes[i] {
			return false
		}
	}
	return true
}
func (this *AggregateExpression_Arg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateExpression_Arg)
	if !ok {
		that2, ok := that.(AggregateExpression_Arg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *AggregateExpression_Arg_Constant) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateExpression_Arg_Constant)
	if !ok {
		that2, ok := that.(AggregateExpression_Arg_Constant)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Constant.Equal(that1.Constant) {
		return false
	}
	return true
}
func (this *AggregateExpression_Arg_Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateExpression_Arg_Column)
	if !ok {
		that2, ok := that.(AggregateExpression_Arg_Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	return true
}
func (this *Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column)
	if !ok {
		that2, ok := that.(Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	return true
}
func (this *PlanOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&planpb.PlanOptions{")
	s = append(s, "Explain: "+fmt.Sprintf("%#v", this.Explain)+",\n")
	s = append(s, "Analyze: "+fmt.Sprintf("%#v", this.Analyze)+",\n")
	s = append(s, "MaxOutputRowsPerTable: "+fmt.Sprintf("%#v", this.MaxOutputRowsPerTable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Plan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&planpb.Plan{")
	if this.Dag != nil {
		s = append(s, "Dag: "+fmt.Sprintf("%#v", this.Dag)+",\n")
	}
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "Distributed: "+fmt.Sprintf("%#v", this.Distributed)+",\n")
	if this.PlanOptions != nil {
		s = append(s, "PlanOptions: "+fmt.Sprintf("%#v", this.PlanOptions)+",\n")
	}
	if this.IncomingAgentIDs != nil {
		s = append(s, "IncomingAgentIDs: "+fmt.Sprintf("%#v", this.IncomingAgentIDs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanFragment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&planpb.PlanFragment{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Dag != nil {
		s = append(s, "Dag: "+fmt.Sprintf("%#v", this.Dag)+",\n")
	}
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DAG) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&planpb.DAG{")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DAG_DAGNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&planpb.DAG_DAGNode{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "SortedParents: "+fmt.Sprintf("%#v", this.SortedParents)+",\n")
	s = append(s, "SortedChildren: "+fmt.Sprintf("%#v", this.SortedChildren)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.PlanNode{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Op != nil {
		s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Operator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&planpb.Operator{")
	s = append(s, "OpType: "+fmt.Sprintf("%#v", this.OpType)+",\n")
	if this.Op != nil {
		s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Operator_MemSourceOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_MemSourceOp{` +
		`MemSourceOp:` + fmt.Sprintf("%#v", this.MemSourceOp) + `}`}, ", ")
	return s
}
func (this *Operator_MapOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_MapOp{` +
		`MapOp:` + fmt.Sprintf("%#v", this.MapOp) + `}`}, ", ")
	return s
}
func (this *Operator_AggOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_AggOp{` +
		`AggOp:` + fmt.Sprintf("%#v", this.AggOp) + `}`}, ", ")
	return s
}
func (this *Operator_MemSinkOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_MemSinkOp{` +
		`MemSinkOp:` + fmt.Sprintf("%#v", this.MemSinkOp) + `}`}, ", ")
	return s
}
func (this *Operator_FilterOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_FilterOp{` +
		`FilterOp:` + fmt.Sprintf("%#v", this.FilterOp) + `}`}, ", ")
	return s
}
func (this *Operator_LimitOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_LimitOp{` +
		`LimitOp:` + fmt.Sprintf("%#v", this.LimitOp) + `}`}, ", ")
	return s
}
func (this *Operator_UnionOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_UnionOp{` +
		`UnionOp:` + fmt.Sprintf("%#v", this.UnionOp) + `}`}, ", ")
	return s
}
func (this *Operator_GRPCSourceOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_GRPCSourceOp{` +
		`GRPCSourceOp:` + fmt.Sprintf("%#v", this.GRPCSourceOp) + `}`}, ", ")
	return s
}
func (this *Operator_GRPCSinkOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_GRPCSinkOp{` +
		`GRPCSinkOp:` + fmt.Sprintf("%#v", this.GRPCSinkOp) + `}`}, ", ")
	return s
}
func (this *Operator_JoinOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_JoinOp{` +
		`JoinOp:` + fmt.Sprintf("%#v", this.JoinOp) + `}`}, ", ")
	return s
}
func (this *Operator_UdtfSourceOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.Operator_UdtfSourceOp{` +
		`UdtfSourceOp:` + fmt.Sprintf("%#v", this.UdtfSourceOp) + `}`}, ", ")
	return s
}
func (this *MemorySourceOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&planpb.MemorySourceOperator{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ColumnIdxs: "+fmt.Sprintf("%#v", this.ColumnIdxs)+",\n")
	s = append(s, "ColumnNames: "+fmt.Sprintf("%#v", this.ColumnNames)+",\n")
	s = append(s, "ColumnTypes: "+fmt.Sprintf("%#v", this.ColumnTypes)+",\n")
	if this.StartTime != nil {
		s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	}
	if this.StopTime != nil {
		s = append(s, "StopTime: "+fmt.Sprintf("%#v", this.StopTime)+",\n")
	}
	s = append(s, "Tablet: "+fmt.Sprintf("%#v", this.Tablet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MemorySinkOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&planpb.MemorySinkOperator{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ColumnTypes: "+fmt.Sprintf("%#v", this.ColumnTypes)+",\n")
	s = append(s, "ColumnNames: "+fmt.Sprintf("%#v", this.ColumnNames)+",\n")
	s = append(s, "ColumnSemanticTypes: "+fmt.Sprintf("%#v", this.ColumnSemanticTypes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GRPCSourceOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.GRPCSourceOperator{")
	s = append(s, "ColumnTypes: "+fmt.Sprintf("%#v", this.ColumnTypes)+",\n")
	s = append(s, "ColumnNames: "+fmt.Sprintf("%#v", this.ColumnNames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GRPCSinkOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&planpb.GRPCSinkOperator{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Destination != nil {
		s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GRPCSinkOperator_GRPCSourceID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.GRPCSinkOperator_GRPCSourceID{` +
		`GRPCSourceID:` + fmt.Sprintf("%#v", this.GRPCSourceID) + `}`}, ", ")
	return s
}
func (this *GRPCSinkOperator_TableName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.GRPCSinkOperator_TableName{` +
		`TableName:` + fmt.Sprintf("%#v", this.TableName) + `}`}, ", ")
	return s
}
func (this *MapOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.MapOperator{")
	if this.Expressions != nil {
		s = append(s, "Expressions: "+fmt.Sprintf("%#v", this.Expressions)+",\n")
	}
	s = append(s, "ColumnNames: "+fmt.Sprintf("%#v", this.ColumnNames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AggregateOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&planpb.AggregateOperator{")
	if this.Values != nil {
		s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	}
	if this.Groups != nil {
		s = append(s, "Groups: "+fmt.Sprintf("%#v", this.Groups)+",\n")
	}
	s = append(s, "GroupNames: "+fmt.Sprintf("%#v", this.GroupNames)+",\n")
	s = append(s, "ValueNames: "+fmt.Sprintf("%#v", this.ValueNames)+",\n")
	s = append(s, "Windowed: "+fmt.Sprintf("%#v", this.Windowed)+",\n")
	s = append(s, "PartialAgg: "+fmt.Sprintf("%#v", this.PartialAgg)+",\n")
	s = append(s, "FinalizeResults: "+fmt.Sprintf("%#v", this.FinalizeResults)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FilterOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.FilterOperator{")
	if this.Expression != nil {
		s = append(s, "Expression: "+fmt.Sprintf("%#v", this.Expression)+",\n")
	}
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LimitOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.LimitOperator{")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UnionOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&planpb.UnionOperator{")
	s = append(s, "ColumnNames: "+fmt.Sprintf("%#v", this.ColumnNames)+",\n")
	if this.ColumnMappings != nil {
		s = append(s, "ColumnMappings: "+fmt.Sprintf("%#v", this.ColumnMappings)+",\n")
	}
	s = append(s, "RowsPerBatch: "+fmt.Sprintf("%#v", this.RowsPerBatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UnionOperator_ColumnMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&planpb.UnionOperator_ColumnMapping{")
	s = append(s, "ColumnIndexes: "+fmt.Sprintf("%#v", this.ColumnIndexes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JoinOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&planpb.JoinOperator{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.EqualityConditions != nil {
		s = append(s, "EqualityConditions: "+fmt.Sprintf("%#v", this.EqualityConditions)+",\n")
	}
	if this.OutputColumns != nil {
		s = append(s, "OutputColumns: "+fmt.Sprintf("%#v", this.OutputColumns)+",\n")
	}
	s = append(s, "ColumnNames: "+fmt.Sprintf("%#v", this.ColumnNames)+",\n")
	s = append(s, "RowsPerBatch: "+fmt.Sprintf("%#v", this.RowsPerBatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JoinOperator_EqualityCondition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.JoinOperator_EqualityCondition{")
	s = append(s, "LeftColumnIndex: "+fmt.Sprintf("%#v", this.LeftColumnIndex)+",\n")
	s = append(s, "RightColumnIndex: "+fmt.Sprintf("%#v", this.RightColumnIndex)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JoinOperator_ParentColumn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.JoinOperator_ParentColumn{")
	s = append(s, "ParentIndex: "+fmt.Sprintf("%#v", this.ParentIndex)+",\n")
	s = append(s, "ColumnIndex: "+fmt.Sprintf("%#v", this.ColumnIndex)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UDTFSourceOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.UDTFSourceOperator{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ArgValues != nil {
		s = append(s, "ArgValues: "+fmt.Sprintf("%#v", this.ArgValues)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScalarExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&planpb.ScalarExpression{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScalarExpression_Constant) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarExpression_Constant{` +
		`Constant:` + fmt.Sprintf("%#v", this.Constant) + `}`}, ", ")
	return s
}
func (this *ScalarExpression_Column) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarExpression_Column{` +
		`Column:` + fmt.Sprintf("%#v", this.Column) + `}`}, ", ")
	return s
}
func (this *ScalarExpression_Func) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarExpression_Func{` +
		`Func:` + fmt.Sprintf("%#v", this.Func) + `}`}, ", ")
	return s
}
func (this *ScalarValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&planpb.ScalarValue{")
	s = append(s, "DataType: "+fmt.Sprintf("%#v", this.DataType)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScalarValue_BoolValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarValue_BoolValue{` +
		`BoolValue:` + fmt.Sprintf("%#v", this.BoolValue) + `}`}, ", ")
	return s
}
func (this *ScalarValue_Int64Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarValue_Int64Value{` +
		`Int64Value:` + fmt.Sprintf("%#v", this.Int64Value) + `}`}, ", ")
	return s
}
func (this *ScalarValue_Float64Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarValue_Float64Value{` +
		`Float64Value:` + fmt.Sprintf("%#v", this.Float64Value) + `}`}, ", ")
	return s
}
func (this *ScalarValue_StringValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarValue_StringValue{` +
		`StringValue:` + fmt.Sprintf("%#v", this.StringValue) + `}`}, ", ")
	return s
}
func (this *ScalarValue_Time64NsValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarValue_Time64NsValue{` +
		`Time64NsValue:` + fmt.Sprintf("%#v", this.Time64NsValue) + `}`}, ", ")
	return s
}
func (this *ScalarValue_Uint128Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.ScalarValue_Uint128Value{` +
		`Uint128Value:` + fmt.Sprintf("%#v", this.Uint128Value) + `}`}, ", ")
	return s
}
func (this *ScalarFunc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&planpb.ScalarFunc{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.InitArgs != nil {
		s = append(s, "InitArgs: "+fmt.Sprintf("%#v", this.InitArgs)+",\n")
	}
	if this.Args != nil {
		s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	}
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "ArgsDataTypes: "+fmt.Sprintf("%#v", this.ArgsDataTypes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AggregateExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&planpb.AggregateExpression{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.InitArgs != nil {
		s = append(s, "InitArgs: "+fmt.Sprintf("%#v", this.InitArgs)+",\n")
	}
	if this.Args != nil {
		s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	}
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "ArgsDataTypes: "+fmt.Sprintf("%#v", this.ArgsDataTypes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AggregateExpression_Arg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.AggregateExpression_Arg{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AggregateExpression_Arg_Constant) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.AggregateExpression_Arg_Constant{` +
		`Constant:` + fmt.Sprintf("%#v", this.Constant) + `}`}, ", ")
	return s
}
func (this *AggregateExpression_Arg_Column) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&planpb.AggregateExpression_Arg_Column{` +
		`Column:` + fmt.Sprintf("%#v", this.Column) + `}`}, ", ")
	return s
}
func (this *Column) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&planpb.Column{")
	s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPlan(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *PlanOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxOutputRowsPerTable != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.MaxOutputRowsPerTable))
		i--
		dAtA[i] = 0x20
	}
	if m.Analyze {
		i--
		if m.Analyze {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Explain {
		i--
		if m.Explain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IncomingAgentIDs) > 0 {
		for iNdEx := len(m.IncomingAgentIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncomingAgentIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PlanOptions != nil {
		{
			size, err := m.PlanOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Distributed {
		i--
		if m.Distributed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Dag != nil {
		{
			size, err := m.Dag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlanFragment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanFragment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanFragment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Dag != nil {
		{
			size, err := m.Dag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DAG) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DAG) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DAG) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DAG_DAGNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DAG_DAGNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DAG_DAGNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SortedParents) > 0 {
		dAtA5 := make([]byte, len(m.SortedParents)*10)
		var j4 int
		for _, num := range m.SortedParents {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintPlan(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SortedChildren) > 0 {
		dAtA7 := make([]byte, len(m.SortedChildren)*10)
		var j6 int
		for _, num := range m.SortedChildren {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintPlan(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlanNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Op != nil {
		{
			size, err := m.Op.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Operator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Op != nil {
		{
			size := m.Op.Size()
			i -= size
			if _, err := m.Op.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OpType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OpType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Operator_MemSourceOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_MemSourceOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MemSourceOp != nil {
		{
			size, err := m.MemSourceOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Operator_MapOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_MapOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MapOp != nil {
		{
			size, err := m.MapOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Operator_AggOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_AggOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AggOp != nil {
		{
			size, err := m.AggOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Operator_MemSinkOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_MemSinkOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MemSinkOp != nil {
		{
			size, err := m.MemSinkOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Operator_FilterOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_FilterOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FilterOp != nil {
		{
			size, err := m.FilterOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Operator_LimitOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_LimitOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LimitOp != nil {
		{
			size, err := m.LimitOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Operator_UnionOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_UnionOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnionOp != nil {
		{
			size, err := m.UnionOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Operator_GRPCSourceOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_GRPCSourceOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GRPCSourceOp != nil {
		{
			size, err := m.GRPCSourceOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Operator_JoinOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_JoinOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JoinOp != nil {
		{
			size, err := m.JoinOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Operator_UdtfSourceOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_UdtfSourceOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UdtfSourceOp != nil {
		{
			size, err := m.UdtfSourceOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Operator_GRPCSinkOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator_GRPCSinkOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GRPCSinkOp != nil {
		{
			size, err := m.GRPCSinkOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *MemorySourceOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemorySourceOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemorySourceOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tablet) > 0 {
		i -= len(m.Tablet)
		copy(dAtA[i:], m.Tablet)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Tablet)))
		i--
		dAtA[i] = 0x3a
	}
	if m.StopTime != nil {
		{
			size, err := m.StopTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ColumnTypes) > 0 {
		dAtA23 := make([]byte, len(m.ColumnTypes)*10)
		var j22 int
		for _, num := range m.ColumnTypes {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintPlan(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ColumnIdxs) > 0 {
		dAtA25 := make([]byte, len(m.ColumnIdxs)*10)
		var j24 int
		for _, num1 := range m.ColumnIdxs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintPlan(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemorySinkOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemorySinkOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemorySinkOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnSemanticTypes) > 0 {
		dAtA27 := make([]byte, len(m.ColumnSemanticTypes)*10)
		var j26 int
		for _, num := range m.ColumnSemanticTypes {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintPlan(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ColumnTypes) > 0 {
		dAtA29 := make([]byte, len(m.ColumnTypes)*10)
		var j28 int
		for _, num := range m.ColumnTypes {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintPlan(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GRPCSourceOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRPCSourceOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GRPCSourceOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ColumnTypes) > 0 {
		dAtA31 := make([]byte, len(m.ColumnTypes)*10)
		var j30 int
		for _, num := range m.ColumnTypes {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintPlan(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GRPCSinkOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRPCSinkOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GRPCSinkOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Destination != nil {
		{
			size := m.Destination.Size()
			i -= size
			if _, err := m.Destination.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GRPCSinkOperator_GRPCSourceID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GRPCSinkOperator_GRPCSourceID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.GRPCSourceID))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *GRPCSinkOperator_TableName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GRPCSinkOperator_TableName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.TableName)
	copy(dAtA[i:], m.TableName)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *MapOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Expressions) > 0 {
		for iNdEx := len(m.Expressions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Expressions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AggregateOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FinalizeResults {
		i--
		if m.FinalizeResults {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.PartialAgg {
		i--
		if m.PartialAgg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Windowed {
		i--
		if m.Windowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ValueNames) > 0 {
		for iNdEx := len(m.ValueNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ValueNames[iNdEx])
			copy(dAtA[i:], m.ValueNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ValueNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.GroupNames) > 0 {
		for iNdEx := len(m.GroupNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupNames[iNdEx])
			copy(dAtA[i:], m.GroupNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.GroupNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FilterOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FilterOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Expression != nil {
		{
			size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimitOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimitOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimitOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Limit != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnionOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnionOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnionOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RowsPerBatch != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowsPerBatch))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ColumnMappings) > 0 {
		for iNdEx := len(m.ColumnMappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ColumnMappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnionOperator_ColumnMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnionOperator_ColumnMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnionOperator_ColumnMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIndexes) > 0 {
		dAtA34 := make([]byte, len(m.ColumnIndexes)*10)
		var j33 int
		for _, num1 := range m.ColumnIndexes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintPlan(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JoinOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RowsPerBatch != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowsPerBatch))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.OutputColumns) > 0 {
		for iNdEx := len(m.OutputColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutputColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EqualityConditions) > 0 {
		for iNdEx := len(m.EqualityConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EqualityConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JoinOperator_EqualityCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinOperator_EqualityCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinOperator_EqualityCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RightColumnIndex != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RightColumnIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.LeftColumnIndex != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.LeftColumnIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JoinOperator_ParentColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinOperator_ParentColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinOperator_ParentColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnIndex != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColumnIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ParentIndex != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ParentIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UDTFSourceOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDTFSourceOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UDTFSourceOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ArgValues) > 0 {
		for iNdEx := len(m.ArgValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArgValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScalarExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScalarExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScalarExpression_Constant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarExpression_Constant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Constant != nil {
		{
			size, err := m.Constant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ScalarExpression_Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarExpression_Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ScalarExpression_Func) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarExpression_Func) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Func != nil {
		{
			size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ScalarValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScalarValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DataType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScalarValue_BoolValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarValue_BoolValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ScalarValue_Int64Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarValue_Int64Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Int64Value))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ScalarValue_Float64Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarValue_Float64Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Float64Value))))
	i--
	dAtA[i] = 0x21
	return len(dAtA) - i, nil
}
func (m *ScalarValue_StringValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarValue_StringValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringValue)
	copy(dAtA[i:], m.StringValue)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.StringValue)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *ScalarValue_Time64NsValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarValue_Time64NsValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Time64NsValue))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *ScalarValue_Uint128Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarValue_Uint128Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Uint128Value != nil {
		{
			size, err := m.Uint128Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ScalarFunc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScalarFunc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarFunc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ArgsDataTypes) > 0 {
		dAtA40 := make([]byte, len(m.ArgsDataTypes)*10)
		var j39 int
		for _, num := range m.ArgsDataTypes {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		i -= j39
		copy(dAtA[i:], dAtA40[:j39])
		i = encodeVarintPlan(dAtA, i, uint64(j39))
		i--
		dAtA[i] = 0x2a
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitArgs) > 0 {
		for iNdEx := len(m.InitArgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InitArgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AggregateExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ArgsDataTypes) > 0 {
		dAtA42 := make([]byte, len(m.ArgsDataTypes)*10)
		var j41 int
		for _, num := range m.ArgsDataTypes {
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintPlan(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0x3a
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.InitArgs) > 0 {
		for iNdEx := len(m.InitArgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InitArgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *AggregateExpression_Arg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateExpression_Arg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateExpression_Arg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AggregateExpression_Arg_Constant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateExpression_Arg_Constant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Constant != nil {
		{
			size, err := m.Constant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AggregateExpression_Arg_Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateExpression_Arg_Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Node != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPlan(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlan(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PlanOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Explain {
		n += 2
	}
	if m.Analyze {
		n += 2
	}
	if m.MaxOutputRowsPerTable != 0 {
		n += 1 + sovPlan(uint64(m.MaxOutputRowsPerTable))
	}
	return n
}

func (m *Plan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dag != nil {
		l = m.Dag.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Distributed {
		n += 2
	}
	if m.PlanOptions != nil {
		l = m.PlanOptions.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IncomingAgentIDs) > 0 {
		for _, e := range m.IncomingAgentIDs {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	return n
}

func (m *PlanFragment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if m.Dag != nil {
		l = m.Dag.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	return n
}

func (m *DAG) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	return n
}

func (m *DAG_DAGNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if len(m.SortedChildren) > 0 {
		l = 0
		for _, e := range m.SortedChildren {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.SortedParents) > 0 {
		l = 0
		for _, e := range m.SortedParents {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	return n
}

func (m *PlanNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if m.Op != nil {
		l = m.Op.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}

func (m *Operator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpType != 0 {
		n += 1 + sovPlan(uint64(m.OpType))
	}
	if m.Op != nil {
		n += m.Op.Size()
	}
	return n
}

func (m *Operator_MemSourceOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemSourceOp != nil {
		l = m.MemSourceOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_MapOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapOp != nil {
		l = m.MapOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_AggOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggOp != nil {
		l = m.AggOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_MemSinkOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemSinkOp != nil {
		l = m.MemSinkOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_FilterOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FilterOp != nil {
		l = m.FilterOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_LimitOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LimitOp != nil {
		l = m.LimitOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_UnionOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnionOp != nil {
		l = m.UnionOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_GRPCSourceOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GRPCSourceOp != nil {
		l = m.GRPCSourceOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_JoinOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JoinOp != nil {
		l = m.JoinOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_UdtfSourceOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UdtfSourceOp != nil {
		l = m.UdtfSourceOp.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Operator_GRPCSinkOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GRPCSinkOp != nil {
		l = m.GRPCSinkOp.Size()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *MemorySourceOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ColumnIdxs) > 0 {
		l = 0
		for _, e := range m.ColumnIdxs {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.ColumnTypes) > 0 {
		l = 0
		for _, e := range m.ColumnTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.StopTime != nil {
		l = m.StopTime.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Tablet)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}

func (m *MemorySinkOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ColumnTypes) > 0 {
		l = 0
		for _, e := range m.ColumnTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.ColumnSemanticTypes) > 0 {
		l = 0
		for _, e := range m.ColumnSemanticTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	return n
}

func (m *GRPCSourceOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ColumnTypes) > 0 {
		l = 0
		for _, e := range m.ColumnTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	return n
}

func (m *GRPCSinkOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Destination != nil {
		n += m.Destination.Size()
	}
	return n
}

func (m *GRPCSinkOperator_GRPCSourceID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.GRPCSourceID))
	return n
}
func (m *GRPCSinkOperator_TableName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	n += 1 + l + sovPlan(uint64(l))
	return n
}
func (m *MapOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, e := range m.Expressions {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	return n
}

func (m *AggregateOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupNames) > 0 {
		for _, s := range m.GroupNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.ValueNames) > 0 {
		for _, s := range m.ValueNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Windowed {
		n += 2
	}
	if m.PartialAgg {
		n += 2
	}
	if m.FinalizeResults {
		n += 2
	}
	return n
}

func (m *FilterOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expression != nil {
		l = m.Expression.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	return n
}

func (m *LimitOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovPlan(uint64(m.Limit))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	return n
}

func (m *UnionOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.ColumnMappings) > 0 {
		for _, e := range m.ColumnMappings {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.RowsPerBatch != 0 {
		n += 1 + sovPlan(uint64(m.RowsPerBatch))
	}
	return n
}

func (m *UnionOperator_ColumnMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ColumnIndexes) > 0 {
		l = 0
		for _, e := range m.ColumnIndexes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	return n
}

func (m *JoinOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if len(m.EqualityConditions) > 0 {
		for _, e := range m.EqualityConditions {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OutputColumns) > 0 {
		for _, e := range m.OutputColumns {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.RowsPerBatch != 0 {
		n += 1 + sovPlan(uint64(m.RowsPerBatch))
	}
	return n
}

func (m *JoinOperator_EqualityCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftColumnIndex != 0 {
		n += 1 + sovPlan(uint64(m.LeftColumnIndex))
	}
	if m.RightColumnIndex != 0 {
		n += 1 + sovPlan(uint64(m.RightColumnIndex))
	}
	return n
}

func (m *JoinOperator_ParentColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParentIndex != 0 {
		n += 1 + sovPlan(uint64(m.ParentIndex))
	}
	if m.ColumnIndex != 0 {
		n += 1 + sovPlan(uint64(m.ColumnIndex))
	}
	return n
}

func (m *UDTFSourceOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ArgValues) > 0 {
		for _, e := range m.ArgValues {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	return n
}

func (m *ScalarExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *ScalarExpression_Constant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constant != nil {
		l = m.Constant.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *ScalarExpression_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *ScalarExpression_Func) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Func != nil {
		l = m.Func.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *ScalarValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovPlan(uint64(m.DataType))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *ScalarValue_BoolValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ScalarValue_Int64Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Int64Value))
	return n
}
func (m *ScalarValue_Float64Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *ScalarValue_StringValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovPlan(uint64(l))
	return n
}
func (m *ScalarValue_Time64NsValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Time64NsValue))
	return n
}
func (m *ScalarValue_Uint128Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uint128Value != nil {
		l = m.Uint128Value.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *ScalarFunc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.InitArgs) > 0 {
		for _, e := range m.InitArgs {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if len(m.ArgsDataTypes) > 0 {
		l = 0
		for _, e := range m.ArgsDataTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	return n
}

func (m *AggregateExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.InitArgs) > 0 {
		for _, e := range m.InitArgs {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.Size()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if len(m.ArgsDataTypes) > 0 {
		l = 0
		for _, e := range m.ArgsDataTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	return n
}

func (m *AggregateExpression_Arg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *AggregateExpression_Arg_Constant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constant != nil {
		l = m.Constant.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AggregateExpression_Arg_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPlan(uint64(m.Node))
	}
	if m.Index != 0 {
		n += 1 + sovPlan(uint64(m.Index))
	}
	return n
}

func sovPlan(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlan(x uint64) (n int) {
	return sovPlan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *PlanOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanOptions{`,
		`Explain:` + fmt.Sprintf("%v", this.Explain) + `,`,
		`Analyze:` + fmt.Sprintf("%v", this.Analyze) + `,`,
		`MaxOutputRowsPerTable:` + fmt.Sprintf("%v", this.MaxOutputRowsPerTable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Plan) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*PlanFragment{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "PlanFragment", "PlanFragment", 1) + ","
	}
	repeatedStringForNodes += "}"
	repeatedStringForIncomingAgentIDs := "[]*UUID{"
	for _, f := range this.IncomingAgentIDs {
		repeatedStringForIncomingAgentIDs += strings.Replace(fmt.Sprintf("%v", f), "UUID", "proto1.UUID", 1) + ","
	}
	repeatedStringForIncomingAgentIDs += "}"
	s := strings.Join([]string{`&Plan{`,
		`Dag:` + strings.Replace(this.Dag.String(), "DAG", "DAG", 1) + `,`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`Distributed:` + fmt.Sprintf("%v", this.Distributed) + `,`,
		`PlanOptions:` + strings.Replace(this.PlanOptions.String(), "PlanOptions", "PlanOptions", 1) + `,`,
		`IncomingAgentIDs:` + repeatedStringForIncomingAgentIDs + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanFragment) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*PlanNode{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "PlanNode", "PlanNode", 1) + ","
	}
	repeatedStringForNodes += "}"
	s := strings.Join([]string{`&PlanFragment{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Dag:` + strings.Replace(this.Dag.String(), "DAG", "DAG", 1) + `,`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`}`,
	}, "")
	return s
}
func (this *DAG) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*DAG_DAGNode{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(fmt.Sprintf("%v", f), "DAG_DAGNode", "DAG_DAGNode", 1) + ","
	}
	repeatedStringForNodes += "}"
	s := strings.Join([]string{`&DAG{`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`}`,
	}, "")
	return s
}
func (this *DAG_DAGNode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DAG_DAGNode{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`SortedChildren:` + fmt.Sprintf("%v", this.SortedChildren) + `,`,
		`SortedParents:` + fmt.Sprintf("%v", this.SortedParents) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Op:` + strings.Replace(this.Op.String(), "Operator", "Operator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator{`,
		`OpType:` + fmt.Sprintf("%v", this.OpType) + `,`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_MemSourceOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_MemSourceOp{`,
		`MemSourceOp:` + strings.Replace(fmt.Sprintf("%v", this.MemSourceOp), "MemorySourceOperator", "MemorySourceOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_MapOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_MapOp{`,
		`MapOp:` + strings.Replace(fmt.Sprintf("%v", this.MapOp), "MapOperator", "MapOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_AggOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_AggOp{`,
		`AggOp:` + strings.Replace(fmt.Sprintf("%v", this.AggOp), "AggregateOperator", "AggregateOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_MemSinkOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_MemSinkOp{`,
		`MemSinkOp:` + strings.Replace(fmt.Sprintf("%v", this.MemSinkOp), "MemorySinkOperator", "MemorySinkOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_FilterOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_FilterOp{`,
		`FilterOp:` + strings.Replace(fmt.Sprintf("%v", this.FilterOp), "FilterOperator", "FilterOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_LimitOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_LimitOp{`,
		`LimitOp:` + strings.Replace(fmt.Sprintf("%v", this.LimitOp), "LimitOperator", "LimitOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_UnionOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_UnionOp{`,
		`UnionOp:` + strings.Replace(fmt.Sprintf("%v", this.UnionOp), "UnionOperator", "UnionOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_GRPCSourceOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_GRPCSourceOp{`,
		`GRPCSourceOp:` + strings.Replace(fmt.Sprintf("%v", this.GRPCSourceOp), "GRPCSourceOperator", "GRPCSourceOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_JoinOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_JoinOp{`,
		`JoinOp:` + strings.Replace(fmt.Sprintf("%v", this.JoinOp), "JoinOperator", "JoinOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_UdtfSourceOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_UdtfSourceOp{`,
		`UdtfSourceOp:` + strings.Replace(fmt.Sprintf("%v", this.UdtfSourceOp), "UDTFSourceOperator", "UDTFSourceOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operator_GRPCSinkOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operator_GRPCSinkOp{`,
		`GRPCSinkOp:` + strings.Replace(fmt.Sprintf("%v", this.GRPCSinkOp), "GRPCSinkOperator", "GRPCSinkOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemorySourceOperator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemorySourceOperator{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ColumnIdxs:` + fmt.Sprintf("%v", this.ColumnIdxs) + `,`,
		`ColumnNames:` + fmt.Sprintf("%v", this.ColumnNames) + `,`,
		`ColumnTypes:` + fmt.Sprintf("%v", this.ColumnTypes) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Int64Value", "types.Int64Value", 1) + `,`,
		`StopTime:` + strings.Replace(fmt.Sprintf("%v", this.StopTime), "Int64Value", "types.Int64Value", 1) + `,`,
		`Tablet:` + fmt.Sprintf("%v", this.Tablet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemorySinkOperator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemorySinkOperator{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ColumnTypes:` + fmt.Sprintf("%v", this.ColumnTypes) + `,`,
		`ColumnNames:` + fmt.Sprintf("%v", this.ColumnNames) + `,`,
		`ColumnSemanticTypes:` + fmt.Sprintf("%v", this.ColumnSemanticTypes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GRPCSourceOperator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GRPCSourceOperator{`,
		`ColumnTypes:` + fmt.Sprintf("%v", this.ColumnTypes) + `,`,
		`ColumnNames:` + fmt.Sprintf("%v", this.ColumnNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GRPCSinkOperator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GRPCSinkOperator{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Destination:` + fmt.Sprintf("%v", this.Destination) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GRPCSinkOperator_GRPCSourceID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GRPCSinkOperator_GRPCSourceID{`,
		`GRPCSourceID:` + fmt.Sprintf("%v", this.GRPCSourceID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GRPCSinkOperator_TableName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GRPCSinkOperator_TableName{`,
		`TableName:` + fmt.Sprintf("%v", this.TableName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MapOperator) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExpressions := "[]*ScalarExpression{"
	for _, f := range this.Expressions {
		repeatedStringForExpressions += strings.Replace(f.String(), "ScalarExpression", "ScalarExpression", 1) + ","
	}
	repeatedStringForExpressions += "}"
	s := strings.Join([]string{`&MapOperator{`,
		`Expressions:` + repeatedStringForExpressions + `,`,
		`ColumnNames:` + fmt.Sprintf("%v", this.ColumnNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateOperator) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValues := "[]*AggregateExpression{"
	for _, f := range this.Values {
		repeatedStringForValues += strings.Replace(f.String(), "AggregateExpression", "AggregateExpression", 1) + ","
	}
	repeatedStringForValues += "}"
	repeatedStringForGroups := "[]*Column{"
	for _, f := range this.Groups {
		repeatedStringForGroups += strings.Replace(f.String(), "Column", "Column", 1) + ","
	}
	repeatedStringForGroups += "}"
	s := strings.Join([]string{`&AggregateOperator{`,
		`Values:` + repeatedStringForValues + `,`,
		`Groups:` + repeatedStringForGroups + `,`,
		`GroupNames:` + fmt.Sprintf("%v", this.GroupNames) + `,`,
		`ValueNames:` + fmt.Sprintf("%v", this.ValueNames) + `,`,
		`Windowed:` + fmt.Sprintf("%v", this.Windowed) + `,`,
		`PartialAgg:` + fmt.Sprintf("%v", this.PartialAgg) + `,`,
		`FinalizeResults:` + fmt.Sprintf("%v", this.FinalizeResults) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FilterOperator) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForColumns := "[]*Column{"
	for _, f := range this.Columns {
		repeatedStringForColumns += strings.Replace(f.String(), "Column", "Column", 1) + ","
	}
	repeatedStringForColumns += "}"
	s := strings.Join([]string{`&FilterOperator{`,
		`Expression:` + strings.Replace(this.Expression.String(), "ScalarExpression", "ScalarExpression", 1) + `,`,
		`Columns:` + repeatedStringForColumns + `,`,
		`}`,
	}, "")
	return s
}
func (this *LimitOperator) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForColumns := "[]*Column{"
	for _, f := range this.Columns {
		repeatedStringForColumns += strings.Replace(f.String(), "Column", "Column", 1) + ","
	}
	repeatedStringForColumns += "}"
	s := strings.Join([]string{`&LimitOperator{`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Columns:` + repeatedStringForColumns + `,`,
		`}`,
	}, "")
	return s
}
func (this *UnionOperator) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForColumnMappings := "[]*UnionOperator_ColumnMapping{"
	for _, f := range this.ColumnMappings {
		repeatedStringForColumnMappings += strings.Replace(fmt.Sprintf("%v", f), "UnionOperator_ColumnMapping", "UnionOperator_ColumnMapping", 1) + ","
	}
	repeatedStringForColumnMappings += "}"
	s := strings.Join([]string{`&UnionOperator{`,
		`ColumnNames:` + fmt.Sprintf("%v", this.ColumnNames) + `,`,
		`ColumnMappings:` + repeatedStringForColumnMappings + `,`,
		`RowsPerBatch:` + fmt.Sprintf("%v", this.RowsPerBatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UnionOperator_ColumnMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UnionOperator_ColumnMapping{`,
		`ColumnIndexes:` + fmt.Sprintf("%v", this.ColumnIndexes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JoinOperator) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEqualityConditions := "[]*JoinOperator_EqualityCondition{"
	for _, f := range this.EqualityConditions {
		repeatedStringForEqualityConditions += strings.Replace(fmt.Sprintf("%v", f), "JoinOperator_EqualityCondition", "JoinOperator_EqualityCondition", 1) + ","
	}
	repeatedStringForEqualityConditions += "}"
	repeatedStringForOutputColumns := "[]*JoinOperator_ParentColumn{"
	for _, f := range this.OutputColumns {
		repeatedStringForOutputColumns += strings.Replace(fmt.Sprintf("%v", f), "JoinOperator_ParentColumn", "JoinOperator_ParentColumn", 1) + ","
	}
	repeatedStringForOutputColumns += "}"
	s := strings.Join([]string{`&JoinOperator{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`EqualityConditions:` + repeatedStringForEqualityConditions + `,`,
		`OutputColumns:` + repeatedStringForOutputColumns + `,`,
		`ColumnNames:` + fmt.Sprintf("%v", this.ColumnNames) + `,`,
		`RowsPerBatch:` + fmt.Sprintf("%v", this.RowsPerBatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JoinOperator_EqualityCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JoinOperator_EqualityCondition{`,
		`LeftColumnIndex:` + fmt.Sprintf("%v", this.LeftColumnIndex) + `,`,
		`RightColumnIndex:` + fmt.Sprintf("%v", this.RightColumnIndex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JoinOperator_ParentColumn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JoinOperator_ParentColumn{`,
		`ParentIndex:` + fmt.Sprintf("%v", this.ParentIndex) + `,`,
		`ColumnIndex:` + fmt.Sprintf("%v", this.ColumnIndex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UDTFSourceOperator) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForArgValues := "[]*ScalarValue{"
	for _, f := range this.ArgValues {
		repeatedStringForArgValues += strings.Replace(f.String(), "ScalarValue", "ScalarValue", 1) + ","
	}
	repeatedStringForArgValues += "}"
	s := strings.Join([]string{`&UDTFSourceOperator{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ArgValues:` + repeatedStringForArgValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarExpression{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarExpression_Constant) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarExpression_Constant{`,
		`Constant:` + strings.Replace(fmt.Sprintf("%v", this.Constant), "ScalarValue", "ScalarValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarExpression_Column) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarExpression_Column{`,
		`Column:` + strings.Replace(fmt.Sprintf("%v", this.Column), "Column", "Column", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarExpression_Func) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarExpression_Func{`,
		`Func:` + strings.Replace(fmt.Sprintf("%v", this.Func), "ScalarFunc", "ScalarFunc", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarValue{`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarValue_BoolValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarValue_BoolValue{`,
		`BoolValue:` + fmt.Sprintf("%v", this.BoolValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarValue_Int64Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarValue_Int64Value{`,
		`Int64Value:` + fmt.Sprintf("%v", this.Int64Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarValue_Float64Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarValue_Float64Value{`,
		`Float64Value:` + fmt.Sprintf("%v", this.Float64Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarValue_StringValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarValue_StringValue{`,
		`StringValue:` + fmt.Sprintf("%v", this.StringValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarValue_Time64NsValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarValue_Time64NsValue{`,
		`Time64NsValue:` + fmt.Sprintf("%v", this.Time64NsValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarValue_Uint128Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarValue_Uint128Value{`,
		`Uint128Value:` + strings.Replace(fmt.Sprintf("%v", this.Uint128Value), "UInt128", "proto2.UInt128", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarFunc) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInitArgs := "[]*ScalarValue{"
	for _, f := range this.InitArgs {
		repeatedStringForInitArgs += strings.Replace(f.String(), "ScalarValue", "ScalarValue", 1) + ","
	}
	repeatedStringForInitArgs += "}"
	repeatedStringForArgs := "[]*ScalarExpression{"
	for _, f := range this.Args {
		repeatedStringForArgs += strings.Replace(f.String(), "ScalarExpression", "ScalarExpression", 1) + ","
	}
	repeatedStringForArgs += "}"
	s := strings.Join([]string{`&ScalarFunc{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`InitArgs:` + repeatedStringForInitArgs + `,`,
		`Args:` + repeatedStringForArgs + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`ArgsDataTypes:` + fmt.Sprintf("%v", this.ArgsDataTypes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateExpression) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInitArgs := "[]*ScalarValue{"
	for _, f := range this.InitArgs {
		repeatedStringForInitArgs += strings.Replace(f.String(), "ScalarValue", "ScalarValue", 1) + ","
	}
	repeatedStringForInitArgs += "}"
	repeatedStringForArgs := "[]*AggregateExpression_Arg{"
	for _, f := range this.Args {
		repeatedStringForArgs += strings.Replace(fmt.Sprintf("%v", f), "AggregateExpression_Arg", "AggregateExpression_Arg", 1) + ","
	}
	repeatedStringForArgs += "}"
	s := strings.Join([]string{`&AggregateExpression{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`InitArgs:` + repeatedStringForInitArgs + `,`,
		`Args:` + repeatedStringForArgs + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`ArgsDataTypes:` + fmt.Sprintf("%v", this.ArgsDataTypes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateExpression_Arg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregateExpression_Arg{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateExpression_Arg_Constant) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregateExpression_Arg_Constant{`,
		`Constant:` + strings.Replace(fmt.Sprintf("%v", this.Constant), "ScalarValue", "ScalarValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateExpression_Arg_Column) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregateExpression_Arg_Column{`,
		`Column:` + strings.Replace(fmt.Sprintf("%v", this.Column), "Column", "Column", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPlan(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *PlanOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Explain = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Analyze", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Analyze = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOutputRowsPerTable", wireType)
			}
			m.MaxOutputRowsPerTable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOutputRowsPerTable |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dag == nil {
				m.Dag = &DAG{}
			}
			if err := m.Dag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &PlanFragment{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distributed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Distributed = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlanOptions == nil {
				m.PlanOptions = &PlanOptions{}
			}
			if err := m.PlanOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingAgentIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncomingAgentIDs = append(m.IncomingAgentIDs, &proto1.UUID{})
			if err := m.IncomingAgentIDs[len(m.IncomingAgentIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanFragment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanFragment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanFragment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dag == nil {
				m.Dag = &DAG{}
			}
			if err := m.Dag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &PlanNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DAG) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DAG: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DAG: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &DAG_DAGNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DAG_DAGNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DAGNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DAGNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SortedChildren = append(m.SortedChildren, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SortedChildren) == 0 {
					m.SortedChildren = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SortedChildren = append(m.SortedChildren, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedChildren", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SortedParents = append(m.SortedParents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SortedParents) == 0 {
					m.SortedParents = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SortedParents = append(m.SortedParents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedParents", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Op == nil {
				m.Op = &Operator{}
			}
			if err := m.Op.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= OperatorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemSourceOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MemorySourceOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_MemSourceOp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MapOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_MapOp{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AggregateOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_AggOp{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemSinkOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MemorySinkOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_MemSinkOp{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FilterOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_FilterOp{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LimitOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_LimitOp{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnionOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnionOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_UnionOp{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCSourceOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GRPCSourceOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_GRPCSourceOp{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JoinOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_JoinOp{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdtfSourceOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UDTFSourceOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_UdtfSourceOp{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCSinkOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GRPCSinkOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &Operator_GRPCSinkOp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemorySourceOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemorySourceOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemorySourceOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIdxs = append(m.ColumnIdxs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIdxs) == 0 {
					m.ColumnIdxs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIdxs = append(m.ColumnIdxs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIdxs", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v proto2.DataType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= proto2.DataType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnTypes = append(m.ColumnTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ColumnTypes) == 0 {
					m.ColumnTypes = make([]proto2.DataType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v proto2.DataType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= proto2.DataType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnTypes = append(m.ColumnTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnTypes", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &types.Int64Value{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StopTime == nil {
				m.StopTime = &types.Int64Value{}
			}
			if err := m.StopTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tablet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemorySinkOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemorySinkOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemorySinkOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v proto2.DataType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= proto2.DataType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnTypes = append(m.ColumnTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ColumnTypes) == 0 {
					m.ColumnTypes = make([]proto2.DataType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v proto2.DataType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= proto2.DataType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnTypes = append(m.ColumnTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnTypes", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v proto2.SemanticType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= proto2.SemanticType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnSemanticTypes = append(m.ColumnSemanticTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ColumnSemanticTypes) == 0 {
					m.ColumnSemanticTypes = make([]proto2.SemanticType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v proto2.SemanticType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= proto2.SemanticType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnSemanticTypes = append(m.ColumnSemanticTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnSemanticTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRPCSourceOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRPCSourceOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRPCSourceOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v proto2.DataType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= proto2.DataType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnTypes = append(m.ColumnTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ColumnTypes) == 0 {
					m.ColumnTypes = make([]proto2.DataType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v proto2.DataType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= proto2.DataType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnTypes = append(m.ColumnTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnTypes", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRPCSinkOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRPCSinkOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRPCSinkOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCSourceID", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Destination = &GRPCSinkOperator_GRPCSourceID{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = &GRPCSinkOperator_TableName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expressions = append(m.Expressions, &ScalarExpression{})
			if err := m.Expressions[len(m.Expressions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &AggregateExpression{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Column{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupNames = append(m.GroupNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueNames = append(m.ValueNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Windowed = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialAgg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartialAgg = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizeResults", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FinalizeResults = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expression == nil {
				m.Expression = &ScalarExpression{}
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimitOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimitOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimitOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnionOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnionOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnionOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnMappings = append(m.ColumnMappings, &UnionOperator_ColumnMapping{})
			if err := m.ColumnMappings[len(m.ColumnMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsPerBatch", wireType)
			}
			m.RowsPerBatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsPerBatch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnionOperator_ColumnMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIndexes = append(m.ColumnIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIndexes) == 0 {
					m.ColumnIndexes = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIndexes = append(m.ColumnIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIndexes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= JoinOperator_JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqualityConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqualityConditions = append(m.EqualityConditions, &JoinOperator_EqualityCondition{})
			if err := m.EqualityConditions[len(m.EqualityConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputColumns = append(m.OutputColumns, &JoinOperator_ParentColumn{})
			if err := m.OutputColumns[len(m.OutputColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsPerBatch", wireType)
			}
			m.RowsPerBatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsPerBatch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinOperator_EqualityCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EqualityCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EqualityCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftColumnIndex", wireType)
			}
			m.LeftColumnIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftColumnIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightColumnIndex", wireType)
			}
			m.RightColumnIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RightColumnIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinOperator_ParentColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParentColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParentColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentIndex", wireType)
			}
			m.ParentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIndex", wireType)
			}
			m.ColumnIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDTFSourceOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDTFSourceOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDTFSourceOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgValues = append(m.ArgValues, &ScalarValue{})
			if err := m.ArgValues[len(m.ArgValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScalarExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScalarExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScalarExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScalarValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ScalarExpression_Constant{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Column{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ScalarExpression_Column{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScalarFunc{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ScalarExpression_Func{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScalarValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScalarValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScalarValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= proto2.DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &ScalarValue_BoolValue{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Value", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &ScalarValue_Int64Value{v}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float64Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &ScalarValue_Float64Value{float64(math.Float64frombits(v))}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &ScalarValue_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time64NsValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &ScalarValue_Time64NsValue{v}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint128Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &proto2.UInt128{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ScalarValue_Uint128Value{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScalarFunc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScalarFunc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScalarFunc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitArgs = append(m.InitArgs, &ScalarValue{})
			if err := m.InitArgs[len(m.InitArgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &ScalarExpression{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v proto2.DataType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= proto2.DataType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArgsDataTypes = append(m.ArgsDataTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ArgsDataTypes) == 0 {
					m.ArgsDataTypes = make([]proto2.DataType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v proto2.DataType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= proto2.DataType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArgsDataTypes = append(m.ArgsDataTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsDataTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitArgs = append(m.InitArgs, &ScalarValue{})
			if err := m.InitArgs[len(m.InitArgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &AggregateExpression_Arg{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v proto2.DataType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= proto2.DataType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArgsDataTypes = append(m.ArgsDataTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ArgsDataTypes) == 0 {
					m.ArgsDataTypes = make([]proto2.DataType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v proto2.DataType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= proto2.DataType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArgsDataTypes = append(m.ArgsDataTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsDataTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateExpression_Arg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Arg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Arg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScalarValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AggregateExpression_Arg_Constant{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Column{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AggregateExpression_Arg_Column{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlan
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlan
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlan
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlan        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlan          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlan = fmt.Errorf("proto: unexpected end of group")
)
